/* tslint:disable */
/* eslint-disable */
/**
 * Zest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@zestlabs.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @enum {string}
 */

export enum AccountAccountStatus {
  Pending = 'PENDING',
  Active = 'ACTIVE',
  Disabled = 'DISABLED',
  Deleted = 'DELETED',
}

/**
 *
 * @export
 * @interface DataBulkCreateResponse
 */
export interface DataBulkCreateResponse {
  /**
   * Successful creation
   * @type {Array<DataPersistResponse>}
   * @memberof DataBulkCreateResponse
   */
  result?: Array<DataPersistResponse>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkCreateResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataBulkDeleteResponse
 */
export interface DataBulkDeleteResponse {
  /**
   * Successful deletion
   * @type {Array<DataPersistResponse>}
   * @memberof DataBulkDeleteResponse
   */
  result?: Array<DataPersistResponse>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkDeleteResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataBulkUpdateResponse
 */
export interface DataBulkUpdateResponse {
  /**
   * Successful creation
   * @type {Array<DataPersistResponse>}
   * @memberof DataBulkUpdateResponse
   */
  result?: Array<DataPersistResponse>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkUpdateResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataDocument
 */
export interface DataDocument {
  /**
   *
   * @type {string}
   * @memberof DataDocument
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof DataDocument
   */
  _rev?: string;
  /**
   * Optional field for USER and FILTERED pools.
   * @type {Array<string>}
   * @memberof DataDocument
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface DataListResponse
 */
export interface DataListResponse {
  /**
   * The number of rows in the database
   * @type {number}
   * @memberof DataListResponse
   */
  total_rows?: number;
  /**
   * Current offset
   * @type {number}
   * @memberof DataListResponse
   */
  offset?: number;
  /**
   *
   * @type {Array<DataDocument>}
   * @memberof DataListResponse
   */
  rows?: Array<DataDocument>;
}
/**
 *
 * @export
 * @interface DataPersistResponse
 */
export interface DataPersistResponse {
  /**
   *
   * @type {string}
   * @memberof DataPersistResponse
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DataPersistResponse
   */
  rev?: string;
}
/**
 *
 * @export
 * @interface DistrconfigActivatePoolRequest
 */
export interface DistrconfigActivatePoolRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigActivatePoolRequest
   */
  id?: string;
}
/**
 *
 * @export
 * @interface DistrconfigAssignAppToUsersRequest
 */
export interface DistrconfigAssignAppToUsersRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignAppToUsersRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignAppToUsersRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignAppToUsersResponse
 */
export interface DistrconfigAssignAppToUsersResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignAppToUsersResponse
   */
  failedUserIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignPoolsToAppRequest
 */
export interface DistrconfigAssignPoolsToAppRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignPoolsToAppRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignPoolsToAppRequest
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignPoolsToAppResponse
 */
export interface DistrconfigAssignPoolsToAppResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignPoolsToAppResponse
   */
  failedPoolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignTagToUserRequest
 */
export interface DistrconfigAssignTagToUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface DistrconfigCreatePoolsRequest
 */
export interface DistrconfigCreatePoolsRequest {
  /**
   *
   * @type {Array<DistrconfigDataPool>}
   * @memberof DistrconfigCreatePoolsRequest
   */
  dataPools?: Array<DistrconfigDataPool>;
}
/**
 *
 * @export
 * @interface DistrconfigCreateUserRequest
 */
export interface DistrconfigCreateUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigCreateUserRequest
   */
  id?: string;
}
/**
 *
 * @export
 * @interface DistrconfigDataPool
 */
export interface DistrconfigDataPool {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  id?: string;
  /**
   *
   * @type {DistrconfigPoolType}
   * @memberof DistrconfigDataPool
   */
  poolType?: DistrconfigPoolType;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigDataPool
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  onUploadFunction?: string;
}
/**
 *
 * @export
 * @interface DistrconfigDataPoolShort
 */
export interface DistrconfigDataPoolShort {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPoolShort
   */
  id?: string;
  /**
   *
   * @type {DistrconfigPoolType}
   * @memberof DistrconfigDataPoolShort
   */
  poolType?: DistrconfigPoolType;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigDataPoolShort
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface DistrconfigDistributionUser
 */
export interface DistrconfigDistributionUser {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDistributionUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDistributionUser
   */
  activeAppID?: string;
  /**
   *
   * @type {Array<DistrconfigUserTagAssignment>}
   * @memberof DistrconfigDistributionUser
   */
  tagAssignments?: Array<DistrconfigUserTagAssignment>;
}
/**
 *
 * @export
 * @interface DistrconfigGetAppResponse
 */
export interface DistrconfigGetAppResponse {
  /**
   *
   * @type {DistrconfigMobileAppWithPools}
   * @memberof DistrconfigGetAppResponse
   */
  app?: DistrconfigMobileAppWithPools;
}
/**
 *
 * @export
 * @interface DistrconfigGetAppsResponse
 */
export interface DistrconfigGetAppsResponse {
  /**
   *
   * @type {Array<DistrconfigMobileAppWithPools>}
   * @memberof DistrconfigGetAppsResponse
   */
  apps?: Array<DistrconfigMobileAppWithPools>;
}
/**
 *
 * @export
 * @interface DistrconfigGetPoolDistributionResponse
 */
export interface DistrconfigGetPoolDistributionResponse {
  /**
   *
   * @type {string}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  dbUrl?: string;
  /**
   *
   * @type {DistrconfigPoolType}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  poolType?: DistrconfigPoolType;
  /**
   *
   * @type {string}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  tagPrefix?: string;
}
/**
 *
 * @export
 * @interface DistrconfigGetPoolResponse
 */
export interface DistrconfigGetPoolResponse {
  /**
   *
   * @type {DistrconfigDataPool}
   * @memberof DistrconfigGetPoolResponse
   */
  dataPool?: DistrconfigDataPool;
}
/**
 *
 * @export
 * @interface DistrconfigGetPoolsResponse
 */
export interface DistrconfigGetPoolsResponse {
  /**
   *
   * @type {Array<DistrconfigDataPoolShort>}
   * @memberof DistrconfigGetPoolsResponse
   */
  dataPool?: Array<DistrconfigDataPoolShort>;
  /**
   *
   * @type {{ [key: string]: DistrconfigPoolSize; }}
   * @memberof DistrconfigGetPoolsResponse
   */
  poolSizes?: { [key: string]: DistrconfigPoolSize };
}
/**
 *
 * @export
 * @interface DistrconfigGetUserResponse
 */
export interface DistrconfigGetUserResponse {
  /**
   *
   * @type {DistrconfigDistributionUser}
   * @memberof DistrconfigGetUserResponse
   */
  user?: DistrconfigDistributionUser;
}
/**
 *
 * @export
 * @interface DistrconfigGetUsersResponse
 */
export interface DistrconfigGetUsersResponse {
  /**
   *
   * @type {Array<DistrconfigDistributionUser>}
   * @memberof DistrconfigGetUsersResponse
   */
  users?: Array<DistrconfigDistributionUser>;
}
/**
 *
 * @export
 * @interface DistrconfigMobileApp
 */
export interface DistrconfigMobileApp {
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileApp
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileApp
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigMobileApp
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface DistrconfigMobileAppWithPools
 */
export interface DistrconfigMobileAppWithPools {
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileAppWithPools
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileAppWithPools
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigMobileAppWithPools
   */
  active?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigMobileAppWithPools
   */
  assignedPools?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigPoolSize
 */
export interface DistrconfigPoolSize {
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  globalDataSizeBytes?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  userDataSizeBytes?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum DistrconfigPoolType {
  Unknown = 'UNKNOWN',
  Global = 'GLOBAL',
  Filtered = 'FILTERED',
  User = 'USER',
}

/**
 *
 * @export
 * @interface DistrconfigUnassignAppFromUsersRequest
 */
export interface DistrconfigUnassignAppFromUsersRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignAppFromUsersRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignAppFromUsersRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignAppFromUsersResponse
 */
export interface DistrconfigUnassignAppFromUsersResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignAppFromUsersResponse
   */
  failedUserIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignPoolsFromAppRequest
 */
export interface DistrconfigUnassignPoolsFromAppRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignPoolsFromAppRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignPoolsFromAppRequest
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignPoolsFromAppResponse
 */
export interface DistrconfigUnassignPoolsFromAppResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignPoolsFromAppResponse
   */
  failedPoolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignTagFromUserRequest
 */
export interface DistrconfigUnassignTagFromUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface DistrconfigUserTagAssignment
 */
export interface DistrconfigUserTagAssignment {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUserTagAssignment
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUserTagAssignment
   */
  value?: string;
}
/**
 *
 * @export
 * @interface DistrconfigValidatePoolDataRequest
 */
export interface DistrconfigValidatePoolDataRequest {
  /**
   *
   * @type {DistrconfigPoolType}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  poolType?: DistrconfigPoolType;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  data?: string;
}
/**
 *
 * @export
 * @interface DistrconfigValidatePoolDataResponse
 */
export interface DistrconfigValidatePoolDataResponse {
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  derivedPk?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  derivedTag?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  validationErrors?: Array<string>;
}
/**
 *
 * @export
 * @interface FunctionsCallAsyncFunctionRequest
 */
export interface FunctionsCallAsyncFunctionRequest {
  /**
   *
   * @type {FunctionsCallFunctionRequest}
   * @memberof FunctionsCallAsyncFunctionRequest
   */
  call?: FunctionsCallFunctionRequest;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallAsyncFunctionRequest
   */
  reason?: string;
}
/**
 *
 * @export
 * @interface FunctionsCallFunctionRequest
 */
export interface FunctionsCallFunctionRequest {
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionRequest
   */
  id?: string;
  /**
   *
   * @type {object}
   * @memberof FunctionsCallFunctionRequest
   */
  payload?: object;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionRequest
   */
  payloadJSON?: string;
}
/**
 *
 * @export
 * @interface FunctionsCallFunctionResponse
 */
export interface FunctionsCallFunctionResponse {
  /**
   *
   * @type {boolean}
   * @memberof FunctionsCallFunctionResponse
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionResponse
   */
  err?: string;
  /**
   *
   * @type {object}
   * @memberof FunctionsCallFunctionResponse
   */
  body?: object;
}
/**
 *
 * @export
 * @interface FunctionsCaller
 */
export interface FunctionsCaller {
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  policies?: string;
}
/**
 *
 * @export
 * @interface FunctionsCreateFunctionRequest
 */
export interface FunctionsCreateFunctionRequest {
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  config?: string;
}
/**
 *
 * @export
 * @interface FunctionsCreateFunctionResponse
 */
export interface FunctionsCreateFunctionResponse {
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionResponse
   */
  id?: string;
}
/**
 *
 * @export
 * @interface FunctionsFunction
 */
export interface FunctionsFunction {
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  config?: string;
}
/**
 *
 * @export
 * @interface FunctionsGetFunctionResponse
 */
export interface FunctionsGetFunctionResponse {
  /**
   *
   * @type {FunctionsFunction}
   * @memberof FunctionsGetFunctionResponse
   */
  function?: FunctionsFunction;
  /**
   *
   * @type {FunctionsFunction}
   * @memberof FunctionsGetFunctionResponse
   */
  result?: FunctionsFunction;
}
/**
 *
 * @export
 * @interface FunctionsGetFunctionsResponse
 */
export interface FunctionsGetFunctionsResponse {
  /**
   *
   * @type {Array<FunctionsFunction>}
   * @memberof FunctionsGetFunctionsResponse
   */
  functions?: Array<FunctionsFunction>;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  bundleUrl?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum LogEntrySeverity {
  Unknown = 'UNKNOWN',
  Trace = 'TRACE',
  Info = 'INFO',
  Warning = 'WARNING',
  Error = 'ERROR',
  Audit = 'AUDIT',
  All = 'ALL',
}

/**
 *
 * @export
 * @enum {string}
 */

export enum PaymentDetailsPaymentType {
  CreditCard = 'CreditCard',
  Paypal = 'Paypal',
  DirectDebig = 'DirectDebig',
  Invoice = 'Invoice',
}

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  [key: string]: object | any;

  /**
   * A URL/resource name whose content describes the type of the serialized protocol buffer message.  For URLs which use the scheme `http`, `https`, or no scheme, the following restrictions and interpretations apply:  * If no scheme is provided, `https` is assumed. * The last segment of the URL\'s path must represent the fully   qualified name of the type (as in `path/google.protobuf.Duration`).   The name should be in a canonical form (e.g., leading \".\" is   not accepted). * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof ProtobufAny
   */
  '@type'?: string;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */

export enum ProtobufNullValue {
  NullValue = 'NULL_VALUE',
}

/**
 *
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
  /**
   *
   * @type {number}
   * @memberof RpcStatus
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof RpcStatus
   */
  message?: string;
  /**
   *
   * @type {Array<ProtobufAny>}
   * @memberof RpcStatus
   */
  details?: Array<ProtobufAny>;
}
/**
 *
 * @export
 * @interface V1AccessKey
 */
export interface V1AccessKey {
  /**
   *
   * @type {string}
   * @memberof V1AccessKey
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1AccessKey
   */
  lastUsedAt?: string;
}
/**
 *
 * @export
 * @interface V1Account
 */
export interface V1Account {
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  description?: string;
  /**
   *
   * @type {AccountAccountStatus}
   * @memberof V1Account
   */
  status?: AccountAccountStatus;
  /**
   *
   * @type {V1PaymentDetails}
   * @memberof V1Account
   */
  paymentDetails?: V1PaymentDetails;
  /**
   *
   * @type {V1ContactDetails}
   * @memberof V1Account
   */
  contactDetails?: V1ContactDetails;
}
/**
 *
 * @export
 * @interface V1Action
 */
export interface V1Action {
  /**
   *
   * @type {string}
   * @memberof V1Action
   */
  service?: string;
  /**
   *
   * @type {string}
   * @memberof V1Action
   */
  call?: string;
}
/**
 *
 * @export
 * @interface V1ActivateAccountRequest
 */
export interface V1ActivateAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1ActivateAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToRoleRequest
 */
export interface V1AddPoliciesToRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddPoliciesToRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToRoleRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToRoleResponse
 */
export interface V1AddPoliciesToRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToRoleResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToUserRequest
 */
export interface V1AddPoliciesToUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddPoliciesToUserRequest
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToUserRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToUserResponse
 */
export interface V1AddPoliciesToUserResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToUserResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddUsersToRoleRequest
 */
export interface V1AddUsersToRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddUsersToRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddUsersToRoleResponse
 */
export interface V1AddUsersToRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleResponse
   */
  failedUserIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AssumeAccountRequest
 */
export interface V1AssumeAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1AssumeAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1CheckHMACAuthRequest
 */
export interface V1CheckHMACAuthRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  httpMethod?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  requestPath?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  contentType?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  md5Body?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface V1CheckHMACAuthResponse
 */
export interface V1CheckHMACAuthResponse {
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthResponse
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthResponse
   */
  error?: string;
}
/**
 *
 * @export
 * @interface V1CheckTokenAuthRequest
 */
export interface V1CheckTokenAuthRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface V1CheckTokenAuthResponse
 */
export interface V1CheckTokenAuthResponse {
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthResponse
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthResponse
   */
  error?: string;
}
/**
 *
 * @export
 * @interface V1CheckUsernameExistsRequest
 */
export interface V1CheckUsernameExistsRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckUsernameExistsRequest
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckUsernameExistsRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1CheckUsernameExistsResponse
 */
export interface V1CheckUsernameExistsResponse {
  /**
   *
   * @type {boolean}
   * @memberof V1CheckUsernameExistsResponse
   */
  exists?: boolean;
}
/**
 *
 * @export
 * @interface V1ContactDetails
 */
export interface V1ContactDetails {
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  main?: string;
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  finance?: string;
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  technical?: string;
}
/**
 *
 * @export
 * @interface V1CreateAccessKeyRequest
 */
export interface V1CreateAccessKeyRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1CreateAccessKeyResponse
 */
export interface V1CreateAccessKeyResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyResponse
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyResponse
   */
  accessSecret?: string;
}
/**
 *
 * @export
 * @interface V1CreateClientRequest
 */
export interface V1CreateClientRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  suffix?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface V1CreateClientResponse
 */
export interface V1CreateClientResponse {
  /**
   *
   * @type {V1OIDCClient}
   * @memberof V1CreateClientResponse
   */
  client?: V1OIDCClient;
}
/**
 *
 * @export
 * @interface V1CreateFederationConfigRequest
 */
export interface V1CreateFederationConfigRequest {
  /**
   *
   * @type {V1FederationType}
   * @memberof V1CreateFederationConfigRequest
   */
  fedType?: V1FederationType;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcUseSecret?: boolean;
}
/**
 *
 * @export
 * @interface V1CreateFederationConfigResponse
 */
export interface V1CreateFederationConfigResponse {
  /**
   *
   * @type {V1FederationConfig}
   * @memberof V1CreateFederationConfigResponse
   */
  config?: V1FederationConfig;
}
/**
 *
 * @export
 * @interface V1CreateNewAccountRequest
 */
export interface V1CreateNewAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountRequest
   */
  description?: string;
  /**
   *
   * @type {V1PaymentDetails}
   * @memberof V1CreateNewAccountRequest
   */
  paymentDetails?: V1PaymentDetails;
  /**
   *
   * @type {V1ContactDetails}
   * @memberof V1CreateNewAccountRequest
   */
  contactDetails?: V1ContactDetails;
}
/**
 *
 * @export
 * @interface V1CreateNewAccountResponse
 */
export interface V1CreateNewAccountResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountResponse
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1CreatePolicyRequest
 */
export interface V1CreatePolicyRequest {
  /**
   *
   * @type {V1Policy}
   * @memberof V1CreatePolicyRequest
   */
  policy?: V1Policy;
}
/**
 *
 * @export
 * @interface V1CreatePolicyResponse
 */
export interface V1CreatePolicyResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreatePolicyResponse
   */
  policyID?: string;
}
/**
 *
 * @export
 * @interface V1CreateRoleRequest
 */
export interface V1CreateRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleRequest
   */
  description?: string;
}
/**
 *
 * @export
 * @interface V1CreateRoleResponse
 */
export interface V1CreateRoleResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleResponse
   */
  roleID?: string;
}
/**
 *
 * @export
 * @interface V1CreateUserRequest
 */
export interface V1CreateUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  federationID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  phoneNumber?: string;
}
/**
 *
 * @export
 * @interface V1CreateUserResponse
 */
export interface V1CreateUserResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateUserResponse
   */
  userID?: string;
}
/**
 * A DataPoint represents a single data point in a metrics series and consists  of a timestamp and the value for the metric at the specific time.
 * @export
 * @interface V1DataPoint
 */
export interface V1DataPoint {
  /**
   *
   * @type {string}
   * @memberof V1DataPoint
   */
  t?: string;
  /**
   *
   * @type {number}
   * @memberof V1DataPoint
   */
  v?: number;
}
/**
 *
 * @export
 * @interface V1DeactivateAccountRequest
 */
export interface V1DeactivateAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1DeactivateAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1FederationConfig
 */
export interface V1FederationConfig {
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  fedID?: string;
  /**
   *
   * @type {V1FederationType}
   * @memberof V1FederationConfig
   */
  fedType?: V1FederationType;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1FederationConfig
   */
  oidcUseSecret?: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum V1FederationType {
  Oidc = 'Oidc',
}

/**
 *
 * @export
 * @interface V1GetAccountResponse
 */
export interface V1GetAccountResponse {
  /**
   *
   * @type {V1Account}
   * @memberof V1GetAccountResponse
   */
  account?: V1Account;
}
/**
 *
 * @export
 * @interface V1GetClientResponse
 */
export interface V1GetClientResponse {
  /**
   *
   * @type {V1OIDCClient}
   * @memberof V1GetClientResponse
   */
  client?: V1OIDCClient;
}
/**
 *
 * @export
 * @interface V1GetClientsResponse
 */
export interface V1GetClientsResponse {
  /**
   *
   * @type {Array<V1OIDCClient>}
   * @memberof V1GetClientsResponse
   */
  client?: Array<V1OIDCClient>;
}
/**
 *
 * @export
 * @interface V1GetDefaultPoliciesResponse
 */
export interface V1GetDefaultPoliciesResponse {
  /**
   *
   * @type {Array<V1Policy>}
   * @memberof V1GetDefaultPoliciesResponse
   */
  policies?: Array<V1Policy>;
}
/**
 *
 * @export
 * @interface V1GetFederationConfigResponse
 */
export interface V1GetFederationConfigResponse {
  /**
   *
   * @type {V1FederationConfig}
   * @memberof V1GetFederationConfigResponse
   */
  config?: V1FederationConfig;
}
/**
 *
 * @export
 * @interface V1GetLogLabelsResponse
 */
export interface V1GetLogLabelsResponse {
  /**
   *
   * @type {Array<V1LabelValues>}
   * @memberof V1GetLogLabelsResponse
   */
  loglabels?: Array<V1LabelValues>;
}
/**
 * GetMetricsMetaResponse contains a list of metric meta objects, describing all metrics that are currently available in the system.
 * @export
 * @interface V1GetMetricsMetaResponse
 */
export interface V1GetMetricsMetaResponse {
  /**
   *
   * @type {Array<V1MetricMeta>}
   * @memberof V1GetMetricsMetaResponse
   */
  metrics?: Array<V1MetricMeta>;
}
/**
 *
 * @export
 * @interface V1GetPasswordPolicyResponse
 */
export interface V1GetPasswordPolicyResponse {
  /**
   *
   * @type {V1PasswordPolicy}
   * @memberof V1GetPasswordPolicyResponse
   */
  policy?: V1PasswordPolicy;
}
/**
 *
 * @export
 * @interface V1GetPoliciesResponse
 */
export interface V1GetPoliciesResponse {
  /**
   *
   * @type {Array<V1Policy>}
   * @memberof V1GetPoliciesResponse
   */
  policies?: Array<V1Policy>;
}
/**
 *
 * @export
 * @interface V1GetPolicyResponse
 */
export interface V1GetPolicyResponse {
  /**
   *
   * @type {V1Policy}
   * @memberof V1GetPolicyResponse
   */
  policy?: V1Policy;
}
/**
 *
 * @export
 * @interface V1GetRoleResponse
 */
export interface V1GetRoleResponse {
  /**
   *
   * @type {V1Role}
   * @memberof V1GetRoleResponse
   */
  role?: V1Role;
}
/**
 *
 * @export
 * @interface V1GetRolesResponse
 */
export interface V1GetRolesResponse {
  /**
   *
   * @type {Array<V1Role>}
   * @memberof V1GetRolesResponse
   */
  roles?: Array<V1Role>;
}
/**
 *
 * @export
 * @interface V1GetSubaccountsResponse
 */
export interface V1GetSubaccountsResponse {
  /**
   *
   * @type {Array<V1Account>}
   * @memberof V1GetSubaccountsResponse
   */
  accounts?: Array<V1Account>;
}
/**
 *
 * @export
 * @interface V1GetUserAccessKeysResponse
 */
export interface V1GetUserAccessKeysResponse {
  /**
   *
   * @type {Array<V1AccessKey>}
   * @memberof V1GetUserAccessKeysResponse
   */
  keys?: Array<V1AccessKey>;
}
/**
 *
 * @export
 * @interface V1GetUserIDByEmailResponse
 */
export interface V1GetUserIDByEmailResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetUserIDByEmailResponse
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1GetUserInfoResponse
 */
export interface V1GetUserInfoResponse {
  /**
   *
   * @type {V1UserInfo}
   * @memberof V1GetUserInfoResponse
   */
  userInfo?: V1UserInfo;
}
/**
 *
 * @export
 * @interface V1GetUserResponse
 */
export interface V1GetUserResponse {
  /**
   *
   * @type {V1User}
   * @memberof V1GetUserResponse
   */
  user?: V1User;
}
/**
 *
 * @export
 * @interface V1GetUsersForRoleResponse
 */
export interface V1GetUsersForRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1GetUsersForRoleResponse
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1GetUsersResponse
 */
export interface V1GetUsersResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetUsersResponse
   */
  totalRows?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetUsersResponse
   */
  offset?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetUsersResponse
   */
  limit?: number;
  /**
   *
   * @type {Array<V1User>}
   * @memberof V1GetUsersResponse
   */
  users?: Array<V1User>;
}
/**
 * Labels are name-value pairs that are used to annotate metrics or log entries.
 * @export
 * @interface V1Label
 */
export interface V1Label {
  /**
   *
   * @type {string}
   * @memberof V1Label
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Label
   */
  value?: string;
}
/**
 * The LabelFilter is used to filter metrics based on their labels. The filter  can be one of EQ (equals), NE (not-equals), RM (regex-match), and NM (not  matching regex).
 * @export
 * @interface V1LabelFilter
 */
export interface V1LabelFilter {
  /**
   *
   * @type {string}
   * @memberof V1LabelFilter
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1LabelFilter
   */
  value?: string;
  /**
   *
   * @type {V1LabelFilterOperator}
   * @memberof V1LabelFilter
   */
  op?: V1LabelFilterOperator;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum V1LabelFilterOperator {
  Eq = 'EQ',
  Ne = 'NE',
  Rm = 'RM',
  Nm = 'NM',
}

/**
 * LabelValues contain a list of all possible values per label name.
 * @export
 * @interface V1LabelValues
 */
export interface V1LabelValues {
  /**
   *
   * @type {string}
   * @memberof V1LabelValues
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1LabelValues
   */
  values?: Array<string>;
}
/**
 * LogEntry is a single log messsage which consists of a set of fields or  attributes, some of which are available to all messages, and others are  specific to the event that created the message.
 * @export
 * @interface V1LogEntry
 */
export interface V1LogEntry {
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  logId?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  time?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  message?: string;
  /**
   *
   * @type {LogEntrySeverity}
   * @memberof V1LogEntry
   */
  severity?: LogEntrySeverity;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  action?: string;
  /**
   *
   * @type {Array<V1LogEntryField>}
   * @memberof V1LogEntry
   */
  fields?: Array<V1LogEntryField>;
}
/**
 * A log entry field represents one single attribute of the log entry, which consists of a name and value pair and is not part of the default structure of log messages.
 * @export
 * @interface V1LogEntryField
 */
export interface V1LogEntryField {
  /**
   *
   * @type {string}
   * @memberof V1LogEntryField
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntryField
   */
  value?: string;
}
/**
 * Aggregations can be used in metric queries to retrieve a summary of the underlying metric data based on single labels.
 * @export
 * @interface V1MetricAggregation
 */
export interface V1MetricAggregation {
  /**
   *
   * @type {string}
   * @memberof V1MetricAggregation
   */
  name?: string;
  /**
   *
   * @type {V1MetricAggregationOperator}
   * @memberof V1MetricAggregation
   */
  op?: V1MetricAggregationOperator;
  /**
   *
   * @type {boolean}
   * @memberof V1MetricAggregation
   */
  preserve?: boolean;
}
/**
 *
 * @export
 * @enum {string}
 */

export enum V1MetricAggregationOperator {
  Sum = 'SUM',
  Avg = 'AVG',
  Min = 'MIN',
  Max = 'MAX',
}

/**
 * MetricMeta contains a name of a metric and a short description, indicating what this metric is representing.
 * @export
 * @interface V1MetricMeta
 */
export interface V1MetricMeta {
  /**
   *
   * @type {string}
   * @memberof V1MetricMeta
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1MetricMeta
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1MetricMeta
   */
  labels?: Array<string>;
}
/**
 * MetricSeries contains the data for a single metric for a requested time span. The object contains both the labels for the result, as well as the actual  data points.
 * @export
 * @interface V1MetricSeries
 */
export interface V1MetricSeries {
  /**
   *
   * @type {string}
   * @memberof V1MetricSeries
   */
  name?: string;
  /**
   *
   * @type {Array<V1Label>}
   * @memberof V1MetricSeries
   */
  labels?: Array<V1Label>;
  /**
   *
   * @type {Array<V1DataPoint>}
   * @memberof V1MetricSeries
   */
  data?: Array<V1DataPoint>;
}
/**
 *
 * @export
 * @interface V1OIDCClient
 */
export interface V1OIDCClient {
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  secret?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface V1PasswordPolicy
 */
export interface V1PasswordPolicy {
  /**
   *
   * @type {string}
   * @memberof V1PasswordPolicy
   */
  minLength?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useLowerLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useUpperLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useNumbers?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useSpecialCharecters?: boolean;
}
/**
 *
 * @export
 * @interface V1PaymentDetails
 */
export interface V1PaymentDetails {
  /**
   *
   * @type {PaymentDetailsPaymentType}
   * @memberof V1PaymentDetails
   */
  type?: PaymentDetailsPaymentType;
  /**
   *
   * @type {string}
   * @memberof V1PaymentDetails
   */
  info?: string;
}
/**
 *
 * @export
 * @interface V1Permission
 */
export interface V1Permission {
  /**
   *
   * @type {string}
   * @memberof V1Permission
   */
  effect?: string;
  /**
   *
   * @type {Array<V1Action>}
   * @memberof V1Permission
   */
  actions?: Array<V1Action>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1Permission
   */
  scope?: Array<string>;
}
/**
 *
 * @export
 * @interface V1Policy
 */
export interface V1Policy {
  /**
   *
   * @type {string}
   * @memberof V1Policy
   */
  policyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Policy
   */
  name?: string;
  /**
   *
   * @type {Array<V1Permission>}
   * @memberof V1Policy
   */
  permissions?: Array<V1Permission>;
}
/**
 * The QueryLogsRequest contains all parameters for searching for log entries inside the appscape log store. Those parameters will filter the logs that will be retrieved to only provide entries that macht the values in the  request.
 * @export
 * @interface V1QueryLogsRequest
 */
export interface V1QueryLogsRequest {
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  timeTill?: string;
  /**
   *
   * @type {number}
   * @memberof V1QueryLogsRequest
   */
  limit?: number;
  /**
   *
   * @type {Array<V1Label>}
   * @memberof V1QueryLogsRequest
   */
  labels?: Array<V1Label>;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  match?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  notMatch?: string;
}
/**
 * QueryLogsResponse contains a list of log entries that match the request  parameters.
 * @export
 * @interface V1QueryLogsResponse
 */
export interface V1QueryLogsResponse {
  /**
   *
   * @type {Array<V1LogEntry>}
   * @memberof V1QueryLogsResponse
   */
  logs?: Array<V1LogEntry>;
}
/**
 * The QueryMetricsRequest is used to retrieve data for a specific metric in a time period. Additionally, filters can be provided to only retrieve data points for a certain label, as well as aggregations, that can be used to  get a summary over the underlying data.
 * @export
 * @interface V1QueryMetricsRequest
 */
export interface V1QueryMetricsRequest {
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  metric?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  timeTill?: string;
  /**
   *
   * @type {Array<V1LabelFilter>}
   * @memberof V1QueryMetricsRequest
   */
  filters?: Array<V1LabelFilter>;
  /**
   *
   * @type {Array<V1MetricAggregation>}
   * @memberof V1QueryMetricsRequest
   */
  aggregations?: Array<V1MetricAggregation>;
}
/**
 * QueryMetricsResponse contains a list of metrics series objects that hold  data for the respecive metrics, which matches the parameters provided in  the query request.
 * @export
 * @interface V1QueryMetricsResponse
 */
export interface V1QueryMetricsResponse {
  /**
   *
   * @type {Array<V1MetricSeries>}
   * @memberof V1QueryMetricsResponse
   */
  metrics?: Array<V1MetricSeries>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromRoleRequest
 */
export interface V1RemovePoliciesFromRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemovePoliciesFromRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromRoleRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromRoleResponse
 */
export interface V1RemovePoliciesFromRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromRoleResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromUserRequest
 */
export interface V1RemovePoliciesFromUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemovePoliciesFromUserRequest
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromUserRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromUserResponse
 */
export interface V1RemovePoliciesFromUserResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromUserResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemoveUsersFromRoleRequest
 */
export interface V1RemoveUsersFromRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemoveUsersFromRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemoveUsersFromRoleResponse
 */
export interface V1RemoveUsersFromRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleResponse
   */
  failedUserIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface V1ResetPasswordRequest
 */
export interface V1ResetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof V1ResetPasswordRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1Role
 */
export interface V1Role {
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1Role
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RoleUpdate
 */
export interface V1RoleUpdate {
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  description?: string;
}
/**
 *
 * @export
 * @interface V1SetPasswordRequest
 */
export interface V1SetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  userPassword?: string;
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  newPassword?: string;
}
/**
 *
 * @export
 * @interface V1UpdateAccountRequest
 */
export interface V1UpdateAccountRequest {
  /**
   *
   * @type {V1Account}
   * @memberof V1UpdateAccountRequest
   */
  account?: V1Account;
}
/**
 *
 * @export
 * @interface V1UpdateClientResponse
 */
export interface V1UpdateClientResponse {
  /**
   *
   * @type {V1OIDCClient}
   * @memberof V1UpdateClientResponse
   */
  client?: V1OIDCClient;
}
/**
 *
 * @export
 * @interface V1UpdatePolicyRequest
 */
export interface V1UpdatePolicyRequest {
  /**
   *
   * @type {V1Policy}
   * @memberof V1UpdatePolicyRequest
   */
  policy?: V1Policy;
}
/**
 *
 * @export
 * @interface V1UpdateRoleRequest
 */
export interface V1UpdateRoleRequest {
  /**
   *
   * @type {V1RoleUpdate}
   * @memberof V1UpdateRoleRequest
   */
  role?: V1RoleUpdate;
}
/**
 *
 * @export
 * @interface V1UpdateUserRequest
 */
export interface V1UpdateUserRequest {
  /**
   *
   * @type {V1UserUpdate}
   * @memberof V1UpdateUserRequest
   */
  user?: V1UserUpdate;
}
/**
 *
 * @export
 * @interface V1User
 */
export interface V1User {
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  lastLogin?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1User
   */
  policyIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1User
   */
  roleIDs?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  federationID?: string;
}
/**
 *
 * @export
 * @interface V1UserInfo
 */
export interface V1UserInfo {
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  name?: string;
  /**
   *
   * @type {Array<V1Policy>}
   * @memberof V1UserInfo
   */
  policies?: Array<V1Policy>;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  logoutUrl?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  assumedAccountID?: string;
}
/**
 *
 * @export
 * @interface V1UserUpdate
 */
export interface V1UserUpdate {
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  federationID?: string;
}

/**
 * AppscapeServiceApi - axios parameter creator
 * @export
 */
export const AppscapeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogLabels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/appscape/v1/logs/labels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsMeta: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/appscape/v1/metrics/meta`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {V1QueryLogsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLogs: async (body: V1QueryLogsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('queryLogs', 'body', body);
      const localVarPath = `/api/appscape/v1/logs/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {V1QueryMetricsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryMetrics: async (body: V1QueryMetricsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('queryMetrics', 'body', body);
      const localVarPath = `/api/appscape/v1/metrics/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AppscapeServiceApi - functional programming interface
 * @export
 */
export const AppscapeServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppscapeServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogLabels(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetLogLabelsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogLabels(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMetricsMeta(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetMetricsMetaResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsMeta(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {V1QueryLogsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryLogs(
      body: V1QueryLogsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1QueryLogsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryLogs(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {V1QueryMetricsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryMetrics(
      body: V1QueryMetricsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1QueryMetricsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryMetrics(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AppscapeServiceApi - factory interface
 * @export
 */
export const AppscapeServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AppscapeServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogLabels(options?: any): AxiosPromise<V1GetLogLabelsResponse> {
      return localVarFp.getLogLabels(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsMeta(options?: any): AxiosPromise<V1GetMetricsMetaResponse> {
      return localVarFp.getMetricsMeta(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {V1QueryLogsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLogs(body: V1QueryLogsRequest, options?: any): AxiosPromise<V1QueryLogsResponse> {
      return localVarFp.queryLogs(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {V1QueryMetricsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryMetrics(body: V1QueryMetricsRequest, options?: any): AxiosPromise<V1QueryMetricsResponse> {
      return localVarFp.queryMetrics(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppscapeServiceApi - object-oriented interface
 * @export
 * @class AppscapeServiceApi
 * @extends {BaseAPI}
 */
export class AppscapeServiceApi extends BaseAPI {
  /**
   *
   * @summary Retrieve all labels and possible values currently used to index the logs.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public getLogLabels(options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .getLogLabels(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all available metrics in the system, returning metric name and  short description.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public getMetricsMeta(options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .getMetricsMeta(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve all logs that match the provided filters.
   * @param {V1QueryLogsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public queryLogs(body: V1QueryLogsRequest, options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .queryLogs(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve data of a metrics, matching the provided parameters.
   * @param {V1QueryMetricsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public queryMetrics(body: V1QueryMetricsRequest, options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .queryMetrics(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthServiceApi - axios parameter creator
 * @export
 */
export const AuthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1ActivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateAccount: async (body: V1ActivateAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('activateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/activate-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1AddPoliciesToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToRole: async (
      body: V1AddPoliciesToRoleRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addPoliciesToRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/policies/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1AddPoliciesToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToUser: async (
      body: V1AddPoliciesToUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addPoliciesToUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/policies/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1AddUsersToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToRole: async (body: V1AddUsersToRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addUsersToRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/users/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1AssumeAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assumeAccount: async (body: V1AssumeAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assumeAccount', 'body', body);
      const localVarPath = `/api/auth/v1/assume-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Auth API
     * @param {V1CheckHMACAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHMACAuth: async (body: V1CheckHMACAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkHMACAuth', 'body', body);
      const localVarPath = `/api/auth/v1/check-hmac`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1CheckTokenAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTokenAuth: async (body: V1CheckTokenAuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkTokenAuth', 'body', body);
      const localVarPath = `/api/auth/v1/check-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {V1CheckUsernameExistsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameExists: async (
      body: V1CheckUsernameExistsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkUsernameExists', 'body', body);
      const localVarPath = `/api/auth/v1/check-username-exists`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {V1CreateAccessKeyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccessKey: async (body: V1CreateAccessKeyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createAccessKey', 'body', body);
      const localVarPath = `/api/auth/v1/accesskey`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {V1CreateClientRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClient: async (body: V1CreateClientRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createClient', 'body', body);
      const localVarPath = `/api/auth/v1/client`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {V1CreateFederationConfigRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFederationConfig: async (
      body: V1CreateFederationConfigRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createFederationConfig', 'body', body);
      const localVarPath = `/api/auth/v1/federation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {V1CreateNewAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAccount: async (
      body: V1CreateNewAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createNewAccount', 'body', body);
      const localVarPath = `/api/auth/v1/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1CreatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicy: async (body: V1CreatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPolicy', 'body', body);
      const localVarPath = `/api/auth/v1/policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1CreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (body: V1CreateRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createRole', 'body', body);
      const localVarPath = `/api/auth/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1CreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (body: V1CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createUser', 'body', body);
      const localVarPath = `/api/auth/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1DeactivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateAccount: async (
      body: V1DeactivateAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('deactivateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/deactivate-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessKey: async (accessKeyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accessKeyID' is not null or undefined
      assertParamExists('deleteAccessKey', 'accessKeyID', accessKeyID);
      const localVarPath = `/api/auth/v1/accesskey/{accessKeyID}`.replace(
        `{${'accessKeyID'}}`,
        encodeURIComponent(String(accessKeyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteClient', 'id', id);
      const localVarPath = `/api/auth/v1/client/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicy: async (policyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'policyID' is not null or undefined
      assertParamExists('deletePolicy', 'policyID', policyID);
      const localVarPath = `/api/auth/v1/policy/{policyID}`.replace(
        `{${'policyID'}}`,
        encodeURIComponent(String(policyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (roleID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('deleteRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/{roleID}`.replace(`{${'roleID'}}`, encodeURIComponent(String(roleID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('deleteUser', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClient: async (clientID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'clientID' is not null or undefined
      assertParamExists('getClient', 'clientID', clientID);
      const localVarPath = `/api/auth/v1/client/{clientID}`.replace(
        `{${'clientID'}}`,
        encodeURIComponent(String(clientID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPolicies: async (
      offset?: string,
      limit?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/default-policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordPolicy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/password-policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicy: async (policyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'policyID' is not null or undefined
      assertParamExists('getPolicy', 'policyID', policyID);
      const localVarPath = `/api/auth/v1/policy/{policyID}`.replace(
        `{${'policyID'}}`,
        encodeURIComponent(String(policyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (roleID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('getRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/{roleID}`.replace(`{${'roleID'}}`, encodeURIComponent(String(roleID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubaccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/subaccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUser', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccessKeys: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUserAccessKeys', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/accesskeys/{userID}`.replace(
        `{${'userID'}}`,
        encodeURIComponent(String(userID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIDByEmail: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('getUserIDByEmail', 'email', email);
      const localVarPath = `/api/auth/v1/user-id-by-email/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/userinfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (offset?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersForRole: async (
      roleID: string,
      offset?: string,
      limit?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('getUsersForRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/users/{roleID}`.replace(
        `{${'roleID'}}`,
        encodeURIComponent(String(roleID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1RemovePoliciesFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromRole: async (
      body: V1RemovePoliciesFromRoleRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removePoliciesFromRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/policies/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1RemovePoliciesFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromUser: async (
      body: V1RemovePoliciesFromUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removePoliciesFromUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/policies/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1RemoveUsersFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUsersFromRole: async (
      body: V1RemoveUsersFromRoleRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removeUsersFromRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/users/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetAssumeAccount: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resetAssumeAccount', 'body', body);
      const localVarPath = `/api/auth/v1/reset-assume-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (body: V1ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resetPassword', 'body', body);
      const localVarPath = `/api/auth/v1/reset-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Password API
     * @param {V1SetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPassword: async (body: V1SetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setPassword', 'body', body);
      const localVarPath = `/api/auth/v1/set-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {V1UpdateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount: async (
      accountAccountID: string,
      body: V1UpdateAccountRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountAccountID' is not null or undefined
      assertParamExists('updateAccount', 'accountAccountID', accountAccountID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/account/{account.accountID}`.replace(
        `{${'account.accountID'}}`,
        encodeURIComponent(String(accountAccountID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient: async (id: string, body: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateClient', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateClient', 'body', body);
      const localVarPath = `/api/auth/v1/client/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1UpdatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicy: async (body: V1UpdatePolicyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePolicy', 'body', body);
      const localVarPath = `/api/auth/v1/policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {V1UpdateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (body: V1UpdateRoleRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateRole', 'body', body);
      const localVarPath = `/api/auth/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userUserID
     * @param {V1UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userUserID: string,
      body: V1UpdateUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userUserID' is not null or undefined
      assertParamExists('updateUser', 'userUserID', userUserID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/{user.userID}`.replace(
        `{${'user.userID'}}`,
        encodeURIComponent(String(userUserID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthServiceApi - functional programming interface
 * @export
 */
export const AuthServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1ActivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activateAccount(
      body: V1ActivateAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activateAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1AddPoliciesToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPoliciesToRole(
      body: V1AddPoliciesToRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AddPoliciesToRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPoliciesToRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1AddPoliciesToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPoliciesToUser(
      body: V1AddPoliciesToUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AddPoliciesToUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPoliciesToUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1AddUsersToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUsersToRole(
      body: V1AddUsersToRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1AddUsersToRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1AssumeAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assumeAccount(
      body: V1AssumeAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assumeAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Auth API
     * @param {V1CheckHMACAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkHMACAuth(
      body: V1CheckHMACAuthRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CheckHMACAuthResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkHMACAuth(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1CheckTokenAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkTokenAuth(
      body: V1CheckTokenAuthRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CheckTokenAuthResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenAuth(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {V1CheckUsernameExistsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkUsernameExists(
      body: V1CheckUsernameExistsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CheckUsernameExistsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkUsernameExists(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {V1CreateAccessKeyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccessKey(
      body: V1CreateAccessKeyRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateAccessKeyResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessKey(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {V1CreateClientRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createClient(
      body: V1CreateClientRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateClientResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createClient(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {V1CreateFederationConfigRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFederationConfig(
      body: V1CreateFederationConfigRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateFederationConfigResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFederationConfig(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {V1CreateNewAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewAccount(
      body: V1CreateNewAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateNewAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1CreatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPolicy(
      body: V1CreatePolicyRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreatePolicyResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1CreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(
      body: V1CreateRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1CreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body: V1CreateUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1CreateUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1DeactivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deactivateAccount(
      body: V1DeactivateAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccessKey(
      accessKeyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessKey(accessKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClient(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePolicy(
      policyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(policyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(
      roleID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClient(
      clientID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetClientResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClient(clientID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClients(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetClientsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClients(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDefaultPolicies(
      offset?: string,
      limit?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetDefaultPoliciesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultPolicies(offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOwnAccount(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetAccountResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnAccount(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPasswordPolicy(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetPasswordPolicyResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordPolicy(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicies(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetPoliciesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicy(
      policyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetPolicyResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(policyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(
      roleID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(roleID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoles(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetRolesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubaccounts(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetSubaccountsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubaccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAccessKeys(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUserAccessKeysResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccessKeys(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIDByEmail(
      email: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUserIDByEmailResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserIDByEmail(email, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfo(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUserInfoResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      offset?: string,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUsersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersForRole(
      roleID: string,
      offset?: string,
      limit?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1GetUsersForRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersForRole(roleID, offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1RemovePoliciesFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePoliciesFromRole(
      body: V1RemovePoliciesFromRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1RemovePoliciesFromRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePoliciesFromRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1RemovePoliciesFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePoliciesFromUser(
      body: V1RemovePoliciesFromUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1RemovePoliciesFromUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePoliciesFromUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1RemoveUsersFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUsersFromRole(
      body: V1RemoveUsersFromRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1RemoveUsersFromRoleResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUsersFromRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetAssumeAccount(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetAssumeAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      body: V1ResetPasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Password API
     * @param {V1SetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPassword(
      body: V1SetPasswordRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {V1UpdateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccount(
      accountAccountID: string,
      body: V1UpdateAccountRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountAccountID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateClient(
      id: string,
      body: InlineObject,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<V1UpdateClientResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateClient(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1UpdatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePolicy(
      body: V1UpdatePolicyRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {V1UpdateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(
      body: V1UpdateRoleRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userUserID
     * @param {V1UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userUserID: string,
      body: V1UpdateUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userUserID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthServiceApi - factory interface
 * @export
 */
export const AuthServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthServiceApiFp(configuration);
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1ActivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateAccount(body: V1ActivateAccountRequest, options?: any): AxiosPromise<object> {
      return localVarFp.activateAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1AddPoliciesToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToRole(body: V1AddPoliciesToRoleRequest, options?: any): AxiosPromise<V1AddPoliciesToRoleResponse> {
      return localVarFp.addPoliciesToRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1AddPoliciesToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToUser(body: V1AddPoliciesToUserRequest, options?: any): AxiosPromise<V1AddPoliciesToUserResponse> {
      return localVarFp.addPoliciesToUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1AddUsersToRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToRole(body: V1AddUsersToRoleRequest, options?: any): AxiosPromise<V1AddUsersToRoleResponse> {
      return localVarFp.addUsersToRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1AssumeAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assumeAccount(body: V1AssumeAccountRequest, options?: any): AxiosPromise<object> {
      return localVarFp.assumeAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Auth API
     * @param {V1CheckHMACAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHMACAuth(body: V1CheckHMACAuthRequest, options?: any): AxiosPromise<V1CheckHMACAuthResponse> {
      return localVarFp.checkHMACAuth(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1CheckTokenAuthRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTokenAuth(body: V1CheckTokenAuthRequest, options?: any): AxiosPromise<V1CheckTokenAuthResponse> {
      return localVarFp.checkTokenAuth(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {V1CheckUsernameExistsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameExists(
      body: V1CheckUsernameExistsRequest,
      options?: any,
    ): AxiosPromise<V1CheckUsernameExistsResponse> {
      return localVarFp.checkUsernameExists(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {V1CreateAccessKeyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccessKey(body: V1CreateAccessKeyRequest, options?: any): AxiosPromise<V1CreateAccessKeyResponse> {
      return localVarFp.createAccessKey(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {V1CreateClientRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClient(body: V1CreateClientRequest, options?: any): AxiosPromise<V1CreateClientResponse> {
      return localVarFp.createClient(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {V1CreateFederationConfigRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFederationConfig(
      body: V1CreateFederationConfigRequest,
      options?: any,
    ): AxiosPromise<V1CreateFederationConfigResponse> {
      return localVarFp.createFederationConfig(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {V1CreateNewAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAccount(body: V1CreateNewAccountRequest, options?: any): AxiosPromise<V1CreateNewAccountResponse> {
      return localVarFp.createNewAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1CreatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicy(body: V1CreatePolicyRequest, options?: any): AxiosPromise<V1CreatePolicyResponse> {
      return localVarFp.createPolicy(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1CreateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(body: V1CreateRoleRequest, options?: any): AxiosPromise<V1CreateRoleResponse> {
      return localVarFp.createRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1CreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: V1CreateUserRequest, options?: any): AxiosPromise<V1CreateUserResponse> {
      return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {V1DeactivateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateAccount(body: V1DeactivateAccountRequest, options?: any): AxiosPromise<object> {
      return localVarFp.deactivateAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessKey(accessKeyID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteAccessKey(accessKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteClient(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicy(policyID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deletePolicy(policyID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(roleID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteRole(roleID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClient(clientID: string, options?: any): AxiosPromise<V1GetClientResponse> {
      return localVarFp.getClient(clientID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients(options?: any): AxiosPromise<V1GetClientsResponse> {
      return localVarFp.getClients(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPolicies(offset?: string, limit?: string, options?: any): AxiosPromise<V1GetDefaultPoliciesResponse> {
      return localVarFp.getDefaultPolicies(offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAccount(options?: any): AxiosPromise<V1GetAccountResponse> {
      return localVarFp.getOwnAccount(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordPolicy(options?: any): AxiosPromise<V1GetPasswordPolicyResponse> {
      return localVarFp.getPasswordPolicy(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies(options?: any): AxiosPromise<V1GetPoliciesResponse> {
      return localVarFp.getPolicies(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicy(policyID: string, options?: any): AxiosPromise<V1GetPolicyResponse> {
      return localVarFp.getPolicy(policyID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(roleID: string, options?: any): AxiosPromise<V1GetRoleResponse> {
      return localVarFp.getRole(roleID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles(options?: any): AxiosPromise<V1GetRolesResponse> {
      return localVarFp.getRoles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubaccounts(options?: any): AxiosPromise<V1GetSubaccountsResponse> {
      return localVarFp.getSubaccounts(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userID: string, options?: any): AxiosPromise<V1GetUserResponse> {
      return localVarFp.getUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccessKeys(userID: string, options?: any): AxiosPromise<V1GetUserAccessKeysResponse> {
      return localVarFp.getUserAccessKeys(userID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIDByEmail(email: string, options?: any): AxiosPromise<V1GetUserIDByEmailResponse> {
      return localVarFp.getUserIDByEmail(email, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo(options?: any): AxiosPromise<V1GetUserInfoResponse> {
      return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(offset?: string, limit?: number, options?: any): AxiosPromise<V1GetUsersResponse> {
      return localVarFp.getUsers(offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersForRole(
      roleID: string,
      offset?: string,
      limit?: string,
      options?: any,
    ): AxiosPromise<V1GetUsersForRoleResponse> {
      return localVarFp.getUsersForRole(roleID, offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1RemovePoliciesFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromRole(
      body: V1RemovePoliciesFromRoleRequest,
      options?: any,
    ): AxiosPromise<V1RemovePoliciesFromRoleResponse> {
      return localVarFp.removePoliciesFromRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1RemovePoliciesFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromUser(
      body: V1RemovePoliciesFromUserRequest,
      options?: any,
    ): AxiosPromise<V1RemovePoliciesFromUserResponse> {
      return localVarFp.removePoliciesFromUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1RemoveUsersFromRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUsersFromRole(
      body: V1RemoveUsersFromRoleRequest,
      options?: any,
    ): AxiosPromise<V1RemoveUsersFromRoleResponse> {
      return localVarFp.removeUsersFromRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetAssumeAccount(body: object, options?: any): AxiosPromise<object> {
      return localVarFp.resetAssumeAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1ResetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(body: V1ResetPasswordRequest, options?: any): AxiosPromise<object> {
      return localVarFp.resetPassword(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Password API
     * @param {V1SetPasswordRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPassword(body: V1SetPasswordRequest, options?: any): AxiosPromise<object> {
      return localVarFp.setPassword(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {V1UpdateAccountRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(accountAccountID: string, body: V1UpdateAccountRequest, options?: any): AxiosPromise<object> {
      return localVarFp.updateAccount(accountAccountID, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient(id: string, body: InlineObject, options?: any): AxiosPromise<V1UpdateClientResponse> {
      return localVarFp.updateClient(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1UpdatePolicyRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicy(body: V1UpdatePolicyRequest, options?: any): AxiosPromise<object> {
      return localVarFp.updatePolicy(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {V1UpdateRoleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(body: V1UpdateRoleRequest, options?: any): AxiosPromise<object> {
      return localVarFp.updateRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userUserID
     * @param {V1UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userUserID: string, body: V1UpdateUserRequest, options?: any): AxiosPromise<object> {
      return localVarFp.updateUser(userUserID, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthServiceApi - object-oriented interface
 * @export
 * @class AuthServiceApi
 * @extends {BaseAPI}
 */
export class AuthServiceApi extends BaseAPI {
  /**
   *
   * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
   * @param {V1ActivateAccountRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public activateAccount(body: V1ActivateAccountRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .activateAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1AddPoliciesToRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addPoliciesToRole(body: V1AddPoliciesToRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addPoliciesToRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1AddPoliciesToUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addPoliciesToUser(body: V1AddPoliciesToUserRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addPoliciesToUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1AddUsersToRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addUsersToRole(body: V1AddUsersToRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addUsersToRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1AssumeAccountRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public assumeAccount(body: V1AssumeAccountRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .assumeAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Auth API
   * @param {V1CheckHMACAuthRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkHMACAuth(body: V1CheckHMACAuthRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkHMACAuth(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1CheckTokenAuthRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkTokenAuth(body: V1CheckTokenAuthRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkTokenAuth(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
   * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
   * @param {V1CheckUsernameExistsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkUsernameExists(body: V1CheckUsernameExistsRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkUsernameExists(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
   * @summary CreateAccessKey creates a new access key for user
   * @param {V1CreateAccessKeyRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createAccessKey(body: V1CreateAccessKeyRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createAccessKey(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
   * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
   * @param {V1CreateClientRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createClient(body: V1CreateClientRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createClient(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
   * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
   * @param {V1CreateFederationConfigRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createFederationConfig(body: V1CreateFederationConfigRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createFederationConfig(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
   * @param {V1CreateNewAccountRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createNewAccount(body: V1CreateNewAccountRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createNewAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1CreatePolicyRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createPolicy(body: V1CreatePolicyRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createPolicy(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1CreateRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createRole(body: V1CreateRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1CreateUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createUser(body: V1CreateUserRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
   * @param {V1DeactivateAccountRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deactivateAccount(body: V1DeactivateAccountRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deactivateAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
   * @summary DeleteAccessKey deletes access key for user
   * @param {string} accessKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteAccessKey(accessKeyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteAccessKey(accessKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
   * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteClient(id: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteClient(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} policyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deletePolicy(policyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deletePolicy(policyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteRole(roleID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteRole(roleID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteUser(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
   * @summary GetClient loads a specific client.
   * @param {string} clientID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getClient(clientID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getClient(clientID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
   * @summary GetClients loads all clients for account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getClients(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getClients(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [offset]
   * @param {string} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getDefaultPolicies(offset?: string, limit?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getDefaultPolicies(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getOwnAccount(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getOwnAccount(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPasswordPolicy(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPasswordPolicy(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPolicies(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPolicies(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary RBAC API
   * @param {string} policyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPolicy(policyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPolicy(policyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getRole(roleID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getRole(roleID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getRoles(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getSubaccounts(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getSubaccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUser(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
   * @summary GetUserAccessKeys returns all access keys by user
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserAccessKeys(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserAccessKeys(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserIDByEmail(email: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserIDByEmail(email, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary User API
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserInfo(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUsers(offset?: string, limit?: number, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUsers(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {string} [offset]
   * @param {string} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUsersForRole(roleID: string, offset?: string, limit?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUsersForRole(roleID, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1RemovePoliciesFromRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removePoliciesFromRole(body: V1RemovePoliciesFromRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removePoliciesFromRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1RemovePoliciesFromUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removePoliciesFromUser(body: V1RemovePoliciesFromUserRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removePoliciesFromUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1RemoveUsersFromRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removeUsersFromRole(body: V1RemoveUsersFromRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removeUsersFromRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public resetAssumeAccount(body: object, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .resetAssumeAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1ResetPasswordRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public resetPassword(body: V1ResetPasswordRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .resetPassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Password API
   * @param {V1SetPasswordRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public setPassword(body: V1SetPasswordRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .setPassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} accountAccountID
   * @param {V1UpdateAccountRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateAccount(accountAccountID: string, body: V1UpdateAccountRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateAccount(accountAccountID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
   * @summary UpdateClient updates the data for account client.
   * @param {string} id
   * @param {InlineObject} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateClient(id: string, body: InlineObject, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateClient(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1UpdatePolicyRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updatePolicy(body: V1UpdatePolicyRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updatePolicy(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {V1UpdateRoleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateRole(body: V1UpdateRoleRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userUserID
   * @param {V1UpdateUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateUser(userUserID: string, body: V1UpdateUserRequest, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateUser(userUserID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DistrConfigServiceApi - axios parameter creator
 * @export
 */
export const DistrConfigServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {DistrconfigActivatePoolRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePool: async (
      body: DistrconfigActivatePoolRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('activatePool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/activate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {DistrconfigAssignAppToUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAppToUsers: async (
      body: DistrconfigAssignAppToUsersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignAppToUsers', 'body', body);
      const localVarPath = `/api/distribution/v1/app/users/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {DistrconfigAssignPoolsToAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPoolsToApp: async (
      body: DistrconfigAssignPoolsToAppRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignPoolsToApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app/pools/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {DistrconfigAssignTagToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTagToUser: async (
      body: DistrconfigAssignTagToUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignTagToUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user/tags/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create mobile application
     * @param {DistrconfigMobileApp} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApp: async (body: DistrconfigMobileApp, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPool: async (body: DistrconfigDataPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {DistrconfigCreatePoolsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPools: async (
      body: DistrconfigCreatePoolsRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPools', 'body', body);
      const localVarPath = `/api/distribution/v1/pools`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {DistrconfigCreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (body: DistrconfigCreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApp: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteApp', 'id', id);
      const localVarPath = `/api/distribution/v1/app/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePool', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteUser', 'id', id);
      const localVarPath = `/api/distribution/v1/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApp: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getApp', 'id', id);
      const localVarPath = `/api/distribution/v1/app/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/apps`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPool', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolDistribution: async (
      id: string,
      userId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPoolDistribution', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/distribution/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/pools`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUser', 'userID', userID);
      const localVarPath = `/api/distribution/v1/user/{userID}`.replace(
        `{${'userID'}}`,
        encodeURIComponent(String(userID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAppBundle: async (id: string, body: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('setAppBundle', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setAppBundle', 'body', body);
      const localVarPath = `/api/distribution/v1/app/{id}/bundle`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {DistrconfigUnassignAppFromUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAppFromUsers: async (
      body: DistrconfigUnassignAppFromUsersRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignAppFromUsers', 'body', body);
      const localVarPath = `/api/distribution/v1/app/users/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {DistrconfigUnassignPoolsFromAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignPoolsFromApp: async (
      body: DistrconfigUnassignPoolsFromAppRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignPoolsFromApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app/pools/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {DistrconfigUnassignTagFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignTagFromUser: async (
      body: DistrconfigUnassignTagFromUserRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignTagFromUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user/tags/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool: async (body: DistrconfigDataPool, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool2: async (
      dataPoolId: string,
      body: DistrconfigDataPool,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataPoolId' is not null or undefined
      assertParamExists('updatePool2', 'dataPoolId', dataPoolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePool2', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/{dataPool.id}`.replace(
        `{${'dataPool.id'}}`,
        encodeURIComponent(String(dataPoolId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {DistrconfigValidatePoolDataRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePoolData: async (
      body: DistrconfigValidatePoolDataRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('validatePoolData', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DistrConfigServiceApi - functional programming interface
 * @export
 */
export const DistrConfigServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DistrConfigServiceApiAxiosParamCreator(configuration);
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {DistrconfigActivatePoolRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activatePool(
      body: DistrconfigActivatePoolRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activatePool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {DistrconfigAssignAppToUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignAppToUsers(
      body: DistrconfigAssignAppToUsersRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigAssignAppToUsersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignAppToUsers(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {DistrconfigAssignPoolsToAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPoolsToApp(
      body: DistrconfigAssignPoolsToAppRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigAssignPoolsToAppResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPoolsToApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {DistrconfigAssignTagToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignTagToUser(
      body: DistrconfigAssignTagToUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignTagToUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create mobile application
     * @param {DistrconfigMobileApp} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApp(
      body: DistrconfigMobileApp,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPool(
      body: DistrconfigDataPool,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {DistrconfigCreatePoolsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPools(
      body: DistrconfigCreatePoolsRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPools(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {DistrconfigCreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body: DistrconfigCreateUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApp(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApp(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePool(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePool(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApp(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetAppResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApp(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApps(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetAppsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApps(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPool(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetPoolResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolDistribution(
      id: string,
      userId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetPoolDistributionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolDistribution(id, userId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPools(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetPoolsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetUserResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigGetUsersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAppBundle(
      id: string,
      body: InlineObject1,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAppBundle(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {DistrconfigUnassignAppFromUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignAppFromUsers(
      body: DistrconfigUnassignAppFromUsersRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigUnassignAppFromUsersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignAppFromUsers(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {DistrconfigUnassignPoolsFromAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignPoolsFromApp(
      body: DistrconfigUnassignPoolsFromAppRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigUnassignPoolsFromAppResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignPoolsFromApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {DistrconfigUnassignTagFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignTagFromUser(
      body: DistrconfigUnassignTagFromUserRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTagFromUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePool(
      body: DistrconfigDataPool,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePool2(
      dataPoolId: string,
      body: DistrconfigDataPool,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePool2(dataPoolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {DistrconfigValidatePoolDataRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validatePoolData(
      body: DistrconfigValidatePoolDataRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DistrconfigValidatePoolDataResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validatePoolData(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DistrConfigServiceApi - factory interface
 * @export
 */
export const DistrConfigServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DistrConfigServiceApiFp(configuration);
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {DistrconfigActivatePoolRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePool(body: DistrconfigActivatePoolRequest, options?: any): AxiosPromise<object> {
      return localVarFp.activatePool(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {DistrconfigAssignAppToUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAppToUsers(
      body: DistrconfigAssignAppToUsersRequest,
      options?: any,
    ): AxiosPromise<DistrconfigAssignAppToUsersResponse> {
      return localVarFp.assignAppToUsers(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {DistrconfigAssignPoolsToAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPoolsToApp(
      body: DistrconfigAssignPoolsToAppRequest,
      options?: any,
    ): AxiosPromise<DistrconfigAssignPoolsToAppResponse> {
      return localVarFp.assignPoolsToApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {DistrconfigAssignTagToUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTagToUser(body: DistrconfigAssignTagToUserRequest, options?: any): AxiosPromise<object> {
      return localVarFp.assignTagToUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create mobile application
     * @param {DistrconfigMobileApp} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApp(body: DistrconfigMobileApp, options?: any): AxiosPromise<object> {
      return localVarFp.createApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPool(body: DistrconfigDataPool, options?: any): AxiosPromise<object> {
      return localVarFp.createPool(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {DistrconfigCreatePoolsRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPools(body: DistrconfigCreatePoolsRequest, options?: any): AxiosPromise<object> {
      return localVarFp.createPools(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {DistrconfigCreateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: DistrconfigCreateUserRequest, options?: any): AxiosPromise<object> {
      return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApp(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteApp(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePool(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deletePool(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApp(id: string, options?: any): AxiosPromise<DistrconfigGetAppResponse> {
      return localVarFp.getApp(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApps(options?: any): AxiosPromise<DistrconfigGetAppsResponse> {
      return localVarFp.getApps(options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool(id: string, options?: any): AxiosPromise<DistrconfigGetPoolResponse> {
      return localVarFp.getPool(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolDistribution(
      id: string,
      userId?: string,
      options?: any,
    ): AxiosPromise<DistrconfigGetPoolDistributionResponse> {
      return localVarFp.getPoolDistribution(id, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools(options?: any): AxiosPromise<DistrconfigGetPoolsResponse> {
      return localVarFp.getPools(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userID: string, options?: any): AxiosPromise<DistrconfigGetUserResponse> {
      return localVarFp.getUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<DistrconfigGetUsersResponse> {
      return localVarFp.getUsers(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAppBundle(id: string, body: InlineObject1, options?: any): AxiosPromise<object> {
      return localVarFp.setAppBundle(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {DistrconfigUnassignAppFromUsersRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAppFromUsers(
      body: DistrconfigUnassignAppFromUsersRequest,
      options?: any,
    ): AxiosPromise<DistrconfigUnassignAppFromUsersResponse> {
      return localVarFp.unassignAppFromUsers(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {DistrconfigUnassignPoolsFromAppRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignPoolsFromApp(
      body: DistrconfigUnassignPoolsFromAppRequest,
      options?: any,
    ): AxiosPromise<DistrconfigUnassignPoolsFromAppResponse> {
      return localVarFp.unassignPoolsFromApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {DistrconfigUnassignTagFromUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignTagFromUser(body: DistrconfigUnassignTagFromUserRequest, options?: any): AxiosPromise<object> {
      return localVarFp.unassignTagFromUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool(body: DistrconfigDataPool, options?: any): AxiosPromise<object> {
      return localVarFp.updatePool(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {DistrconfigDataPool} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool2(dataPoolId: string, body: DistrconfigDataPool, options?: any): AxiosPromise<object> {
      return localVarFp.updatePool2(dataPoolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {DistrconfigValidatePoolDataRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePoolData(
      body: DistrconfigValidatePoolDataRequest,
      options?: any,
    ): AxiosPromise<DistrconfigValidatePoolDataResponse> {
      return localVarFp.validatePoolData(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DistrConfigServiceApi - object-oriented interface
 * @export
 * @class DistrConfigServiceApi
 * @extends {BaseAPI}
 */
export class DistrConfigServiceApi extends BaseAPI {
  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
   * @param {DistrconfigActivatePoolRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public activatePool(body: DistrconfigActivatePoolRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .activatePool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign mobile application to users
   * @param {DistrconfigAssignAppToUsersRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignAppToUsers(body: DistrconfigAssignAppToUsersRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignAppToUsers(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign data pools to mobile application
   * @param {DistrconfigAssignPoolsToAppRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignPoolsToApp(body: DistrconfigAssignPoolsToAppRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignPoolsToApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign filtering tag to user
   * @param {DistrconfigAssignTagToUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignTagToUser(body: DistrconfigAssignTagToUserRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignTagToUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create mobile application
   * @param {DistrconfigMobileApp} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createApp(body: DistrconfigMobileApp, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Create a data pool that can be used to distribute data to mobile users.
   * @param {DistrconfigDataPool} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createPool(body: DistrconfigDataPool, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createPool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Create several data pools, which can be used to distribute data to mobile users.
   * @param {DistrconfigCreatePoolsRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createPools(body: DistrconfigCreatePoolsRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createPools(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers user in distribution database
   * @param {DistrconfigCreateUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createUser(body: DistrconfigCreateUserRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete mobile application
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deleteApp(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deleteApp(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deletePool(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deletePool(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes user from distribution db
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deleteUser(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deleteUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a mobile application
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getApp(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getApp(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all mobile applications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getApps(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getApps(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the data pool with the given ID.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPool(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPool(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the data distribution details for the pool.
   * @param {string} id
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPoolDistribution(id: string, userId?: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPoolDistribution(id, userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the list of all data pool that have been created in the system.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPools(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPools(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch the user with the given ID
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getUser(userID: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch all users in account distribution db
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getUsers(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set the mobile application bundle
   * @param {string} id
   * @param {InlineObject1} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public setAppBundle(id: string, body: InlineObject1, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .setAppBundle(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign mobile application from users
   * @param {DistrconfigUnassignAppFromUsersRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignAppFromUsers(body: DistrconfigUnassignAppFromUsersRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignAppFromUsers(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign data pool from mobile application
   * @param {DistrconfigUnassignPoolsFromAppRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignPoolsFromApp(body: DistrconfigUnassignPoolsFromAppRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignPoolsFromApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign filtering tag from user
   * @param {DistrconfigUnassignTagFromUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignTagFromUser(body: DistrconfigUnassignTagFromUserRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignTagFromUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Update an already existing data pool.
   * @param {DistrconfigDataPool} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public updatePool(body: DistrconfigDataPool, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .updatePool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Update an already existing data pool.
   * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
   * @param {DistrconfigDataPool} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public updatePool2(dataPoolId: string, body: DistrconfigDataPool, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .updatePool2(dataPoolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Validate pool data against pool specification
   * @param {DistrconfigValidatePoolDataRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public validatePoolData(body: DistrconfigValidatePoolDataRequest, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .validatePoolData(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FunctionsServiceApi - axios parameter creator
 * @export
 */
export const FunctionsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callAsyncFunction: async (
      reason: string,
      callId: string,
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reason' is not null or undefined
      assertParamExists('callAsyncFunction', 'reason', reason);
      // verify required parameter 'callId' is not null or undefined
      assertParamExists('callAsyncFunction', 'callId', callId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callAsyncFunction', 'body', body);
      const localVarPath = `/api/func/v1/post-call/{reason}/{call.id}`
        .replace(`{${'reason'}}`, encodeURIComponent(String(reason)))
        .replace(`{${'call.id'}}`, encodeURIComponent(String(callId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callSyncFunction: async (
      id: string,
      body: object,
      payloadJSON?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('callSyncFunction', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callSyncFunction', 'body', body);
      const localVarPath = `/api/func/v1/call-sync/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (payloadJSON !== undefined) {
        localVarQueryParameter['payloadJSON'] = payloadJSON;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callTestFunction: async (
      id: string,
      body: object,
      payloadJSON?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('callTestFunction', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callTestFunction', 'body', body);
      const localVarPath = `/api/func/v1/call-test/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (payloadJSON !== undefined) {
        localVarQueryParameter['payloadJSON'] = payloadJSON;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create function
     * @param {FunctionsCreateFunctionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFunction: async (
      body: FunctionsCreateFunctionRequest,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createFunction', 'body', body);
      const localVarPath = `/api/func/v1/function`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFunction', 'id', id);
      const localVarPath = `/api/func/v1/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFunction', 'id', id);
      const localVarPath = `/api/func/v1/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/func/v1/functions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update function
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction: async (body: FunctionsFunction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateFunction', 'body', body);
      const localVarPath = `/api/func/v1/function`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction2: async (
      functionId: string,
      body: FunctionsFunction,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'functionId' is not null or undefined
      assertParamExists('updateFunction2', 'functionId', functionId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateFunction2', 'body', body);
      const localVarPath = `/api/func/v1/function/{function.id}`.replace(
        `{${'function.id'}}`,
        encodeURIComponent(String(functionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FunctionsServiceApi - functional programming interface
 * @export
 */
export const FunctionsServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FunctionsServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callAsyncFunction(
      reason: string,
      callId: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callAsyncFunction(reason, callId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callSyncFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionsCallFunctionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callSyncFunction(id, body, payloadJSON, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callTestFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionsCallFunctionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callTestFunction(id, body, payloadJSON, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create function
     * @param {FunctionsCreateFunctionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFunction(
      body: FunctionsCreateFunctionRequest,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionsCreateFunctionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFunction(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFunction(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFunction(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunction(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionsGetFunctionResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunction(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunctions(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionsGetFunctionsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctions(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update function
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFunction(
      body: FunctionsFunction,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunction(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFunction2(
      functionId: string,
      body: FunctionsFunction,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunction2(functionId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FunctionsServiceApi - factory interface
 * @export
 */
export const FunctionsServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FunctionsServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callAsyncFunction(reason: string, callId: string, body: object, options?: any): AxiosPromise<object> {
      return localVarFp.callAsyncFunction(reason, callId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callSyncFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: any,
    ): AxiosPromise<FunctionsCallFunctionResponse> {
      return localVarFp.callSyncFunction(id, body, payloadJSON, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callTestFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: any,
    ): AxiosPromise<FunctionsCallFunctionResponse> {
      return localVarFp.callTestFunction(id, body, payloadJSON, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create function
     * @param {FunctionsCreateFunctionRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFunction(body: FunctionsCreateFunctionRequest, options?: any): AxiosPromise<FunctionsCreateFunctionResponse> {
      return localVarFp.createFunction(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteFunction(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunction(id: string, options?: any): AxiosPromise<FunctionsGetFunctionResponse> {
      return localVarFp.getFunction(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions(options?: any): AxiosPromise<FunctionsGetFunctionsResponse> {
      return localVarFp.getFunctions(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update function
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction(body: FunctionsFunction, options?: any): AxiosPromise<object> {
      return localVarFp.updateFunction(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {FunctionsFunction} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction2(functionId: string, body: FunctionsFunction, options?: any): AxiosPromise<object> {
      return localVarFp.updateFunction2(functionId, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FunctionsServiceApi - object-oriented interface
 * @export
 * @class FunctionsServiceApi
 * @extends {BaseAPI}
 */
export class FunctionsServiceApi extends BaseAPI {
  /**
   *
   * @summary Post function for execution in async way
   * @param {string} reason
   * @param {string} callId
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callAsyncFunction(reason: string, callId: string, body: object, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callAsyncFunction(reason, callId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Call a function synchroniously
   * @param {string} id
   * @param {object} body
   * @param {string} [payloadJSON]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callSyncFunction(id: string, body: object, payloadJSON?: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callSyncFunction(id, body, payloadJSON, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Test a function call
   * @param {string} id
   * @param {object} body
   * @param {string} [payloadJSON]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callTestFunction(id: string, body: object, payloadJSON?: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callTestFunction(id, body, payloadJSON, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create function
   * @param {FunctionsCreateFunctionRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public createFunction(body: FunctionsCreateFunctionRequest, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .createFunction(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete function
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public deleteFunction(id: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .deleteFunction(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get function
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public getFunction(id: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .getFunction(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch all functions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public getFunctions(options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .getFunctions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update function
   * @param {FunctionsFunction} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public updateFunction(body: FunctionsFunction, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .updateFunction(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update function
   * @param {string} functionId
   * @param {FunctionsFunction} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public updateFunction2(functionId: string, body: FunctionsFunction, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .updateFunction2(functionId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PoolDataServiceApi - axios parameter creator
 * @export
 */
export const PoolDataServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreate: async (
      poolId: string,
      body: Array<DataDocument>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkCreate', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkCreate', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDelete: async (
      poolId: string,
      body: Array<DataDocument>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkDelete', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkDelete', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdate: async (
      poolId: string,
      body: Array<DataDocument>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkUpdate', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkUpdate', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('deleteAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('deleteAttachment', 'attname', attname);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (poolId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('get', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('get', 'id', id);
      const localVarPath = `/api/data/_r/{poolId}/{id}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('getAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('getAttachment', 'attname', attname);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      poolId: string,
      limit: number,
      skip: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('list', 'poolId', poolId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('list', 'limit', limit);
      // verify required parameter 'skip' is not null or undefined
      assertParamExists('list', 'skip', skip);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      upfile: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('storeAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('storeAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('storeAttachment', 'attname', attname);
      // verify required parameter 'upfile' is not null or undefined
      assertParamExists('storeAttachment', 'upfile', upfile);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (upfile !== undefined) {
        localVarFormParams.append('upfile', upfile as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PoolDataServiceApi - functional programming interface
 * @export
 */
export const PoolDataServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PoolDataServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreate(
      poolId: string,
      body: Array<DataDocument>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataBulkCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreate(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDelete(
      poolId: string,
      body: Array<DataDocument>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataBulkDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDelete(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdate(
      poolId: string,
      body: Array<DataDocument>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataBulkUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdate(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAttachment(
      poolId: string,
      id: string,
      attname: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(poolId, id, attname, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      poolId: string,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDocument>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(poolId, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttachment(
      poolId: string,
      id: string,
      attname: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(poolId, id, attname, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      poolId: string,
      limit: number,
      skip: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataListResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(poolId, limit, skip, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeAttachment(
      poolId: string,
      id: string,
      attname: string,
      upfile: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeAttachment(poolId, id, attname, upfile, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PoolDataServiceApi - factory interface
 * @export
 */
export const PoolDataServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PoolDataServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreate(poolId: string, body: Array<DataDocument>, options?: any): AxiosPromise<DataBulkCreateResponse> {
      return localVarFp.bulkCreate(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDelete(poolId: string, body: Array<DataDocument>, options?: any): AxiosPromise<DataBulkDeleteResponse> {
      return localVarFp.bulkDelete(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<DataDocument>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdate(poolId: string, body: Array<DataDocument>, options?: any): AxiosPromise<DataBulkUpdateResponse> {
      return localVarFp.bulkUpdate(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttachment(poolId: string, id: string, attname: string, options?: any): AxiosPromise<string> {
      return localVarFp.deleteAttachment(poolId, id, attname, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(poolId: string, id: string, options?: any): AxiosPromise<DataDocument> {
      return localVarFp.get(poolId, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachment(poolId: string, id: string, attname: string, options?: any): AxiosPromise<any> {
      return localVarFp.getAttachment(poolId, id, attname, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(poolId: string, limit: number, skip: number, options?: any): AxiosPromise<DataListResponse> {
      return localVarFp.list(poolId, limit, skip, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeAttachment(poolId: string, id: string, attname: string, upfile: any, options?: any): AxiosPromise<string> {
      return localVarFp
        .storeAttachment(poolId, id, attname, upfile, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PoolDataServiceApi - object-oriented interface
 * @export
 * @class PoolDataServiceApi
 * @extends {BaseAPI}
 */
export class PoolDataServiceApi extends BaseAPI {
  /**
   *
   * @summary Bulk create mobile data records in a pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<DataDocument>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkCreate(poolId: string, body: Array<DataDocument>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkCreate(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Bulk delete records from mobile data pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<DataDocument>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkDelete(poolId: string, body: Array<DataDocument>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkDelete(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Bulk update records in mobile data pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<DataDocument>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkUpdate(poolId: string, body: Array<DataDocument>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkUpdate(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public deleteAttachment(poolId: string, id: string, attname: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .deleteAttachment(poolId, id, attname, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get single mobile data record
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public get(poolId: string, id: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .get(poolId, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public getAttachment(poolId: string, id: string, attname: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .getAttachment(poolId, id, attname, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List mobile data records
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {number} limit The max number of records to fetch.
   * @param {number} skip The records to skip from the beggining
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public list(poolId: string, limit: number, skip: number, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .list(poolId, limit, skip, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Store attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {any} upfile The attachment content file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public storeAttachment(poolId: string, id: string, attname: string, upfile: any, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .storeAttachment(poolId, id, attname, upfile, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
