/* tslint:disable */
/* eslint-disable */
/**
 * Zest API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: contact@zestlabs.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @enum {string}
 */

export const AccountAccountStatus = {
  Pending: 'PENDING',
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Deleted: 'DELETED',
} as const;

export type AccountAccountStatus = typeof AccountAccountStatus[keyof typeof AccountAccountStatus];

/**
 *
 * @export
 * @interface AccountRoles
 */
export interface AccountRoles {
  /**
   *
   * @type {string}
   * @memberof AccountRoles
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof AccountRoles
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof AccountRoles
   */
  accountRole?: string;
}
/**
 * Labels are name-value pairs that are used to annotate metrics or log entries.
 * @export
 * @interface ApiAppscapeV1LogsQueryLabels
 */
export interface ApiAppscapeV1LogsQueryLabels {
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1LogsQueryLabels
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1LogsQueryLabels
   */
  value?: string;
}
/**
 * Aggregations can be used in metric queries to retrieve a summary of the underlying metric data based on single labels.
 * @export
 * @interface ApiAppscapeV1MetricsQueryAggregations
 */
export interface ApiAppscapeV1MetricsQueryAggregations {
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1MetricsQueryAggregations
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1MetricsQueryAggregations
   */
  op?: ApiAppscapeV1MetricsQueryAggregationsOpEnum;
  /**
   *
   * @type {boolean}
   * @memberof ApiAppscapeV1MetricsQueryAggregations
   */
  preserve?: boolean;
}

export const ApiAppscapeV1MetricsQueryAggregationsOpEnum = {
  Sum: 'SUM',
  Avg: 'AVG',
  Min: 'MIN',
  Max: 'MAX',
} as const;

export type ApiAppscapeV1MetricsQueryAggregationsOpEnum = typeof ApiAppscapeV1MetricsQueryAggregationsOpEnum[keyof typeof ApiAppscapeV1MetricsQueryAggregationsOpEnum];

/**
 * The LabelFilter is used to filter metrics based on their labels. The filter  can be one of EQ (equals), NE (not-equals), RM (regex-match), and NM (not  matching regex).
 * @export
 * @interface ApiAppscapeV1MetricsQueryFilters
 */
export interface ApiAppscapeV1MetricsQueryFilters {
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1MetricsQueryFilters
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1MetricsQueryFilters
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAppscapeV1MetricsQueryFilters
   */
  op?: ApiAppscapeV1MetricsQueryFiltersOpEnum;
}

export const ApiAppscapeV1MetricsQueryFiltersOpEnum = {
  Eq: 'EQ',
  Ne: 'NE',
  Rm: 'RM',
  Nm: 'NM',
} as const;

export type ApiAppscapeV1MetricsQueryFiltersOpEnum = typeof ApiAppscapeV1MetricsQueryFiltersOpEnum[keyof typeof ApiAppscapeV1MetricsQueryFiltersOpEnum];

/**
 *
 * @export
 * @interface ApiAuthV1RoleRole
 */
export interface ApiAuthV1RoleRole {
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1RoleRole
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1RoleRole
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1RoleRole
   */
  description?: string;
}
/**
 *
 * @export
 * @interface ApiAuthV1UserUserUserIDUser
 */
export interface ApiAuthV1UserUserUserIDUser {
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof ApiAuthV1UserUserUserIDUser
   */
  federationID?: string;
}
/**
 *
 * @export
 * @interface ContainsDataPoolTaskDataSpecifiedInByIDRequest
 */
export interface ContainsDataPoolTaskDataSpecifiedInByIDRequest {
  /**
   *
   * @type {InlineObject41}
   * @memberof ContainsDataPoolTaskDataSpecifiedInByIDRequest
   */
  dataPool?: InlineObject41;
}
/**
 *
 * @export
 * @interface ContainsListOfAllDataPoolTasks
 */
export interface ContainsListOfAllDataPoolTasks {
  /**
   *
   * @type {Array<ContainsListOfAllDataPoolTasksDataPool>}
   * @memberof ContainsListOfAllDataPoolTasks
   */
  dataPool?: Array<ContainsListOfAllDataPoolTasksDataPool>;
  /**
   *
   * @type {{ [key: string]: ContainsListOfAllDataPoolTasksPoolSizes; }}
   * @memberof ContainsListOfAllDataPoolTasks
   */
  poolSizes?: { [key: string]: ContainsListOfAllDataPoolTasksPoolSizes };
}
/**
 *
 * @export
 * @interface ContainsListOfAllDataPoolTasksDataPool
 */
export interface ContainsListOfAllDataPoolTasksDataPool {
  /**
   *
   * @type {string}
   * @memberof ContainsListOfAllDataPoolTasksDataPool
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ContainsListOfAllDataPoolTasksDataPool
   */
  poolType?: ContainsListOfAllDataPoolTasksDataPoolPoolTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof ContainsListOfAllDataPoolTasksDataPool
   */
  active?: boolean;
}

export const ContainsListOfAllDataPoolTasksDataPoolPoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type ContainsListOfAllDataPoolTasksDataPoolPoolTypeEnum = typeof ContainsListOfAllDataPoolTasksDataPoolPoolTypeEnum[keyof typeof ContainsListOfAllDataPoolTasksDataPoolPoolTypeEnum];

/**
 *
 * @export
 * @interface ContainsListOfAllDataPoolTasksPoolSizes
 */
export interface ContainsListOfAllDataPoolTasksPoolSizes {
  /**
   *
   * @type {string}
   * @memberof ContainsListOfAllDataPoolTasksPoolSizes
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof ContainsListOfAllDataPoolTasksPoolSizes
   */
  globalDataSizeBytes?: string;
  /**
   *
   * @type {string}
   * @memberof ContainsListOfAllDataPoolTasksPoolSizes
   */
  userDataSizeBytes?: string;
}
/**
 *
 * @export
 * @interface DataBulkCreateResponse
 */
export interface DataBulkCreateResponse {
  /**
   * Successful creation
   * @type {Array<InlineResponse20043Result>}
   * @memberof DataBulkCreateResponse
   */
  result?: Array<InlineResponse20043Result>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkCreateResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataBulkDeleteResponse
 */
export interface DataBulkDeleteResponse {
  /**
   * Successful deletion
   * @type {Array<InlineResponse20043Result>}
   * @memberof DataBulkDeleteResponse
   */
  result?: Array<InlineResponse20043Result>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkDeleteResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataBulkUpdateResponse
 */
export interface DataBulkUpdateResponse {
  /**
   * Successful creation
   * @type {Array<InlineResponse20043Result>}
   * @memberof DataBulkUpdateResponse
   */
  result?: Array<InlineResponse20043Result>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof DataBulkUpdateResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface DataDocument
 */
export interface DataDocument {
  /**
   *
   * @type {string}
   * @memberof DataDocument
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof DataDocument
   */
  _rev?: string;
  /**
   * Optional field for USER and FILTERED pools.
   * @type {Array<string>}
   * @memberof DataDocument
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface DataGetResponse
 */
export interface DataGetResponse {
  /**
   *
   * @type {string}
   * @memberof DataGetResponse
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof DataGetResponse
   */
  _rev?: string;
  /**
   * Optional field for USER and FILTERED pools.
   * @type {Array<string>}
   * @memberof DataGetResponse
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface DataListResponse
 */
export interface DataListResponse {
  /**
   * The number of rows in the database
   * @type {number}
   * @memberof DataListResponse
   */
  total_rows?: number;
  /**
   * Current offset
   * @type {number}
   * @memberof DataListResponse
   */
  offset?: number;
  /**
   *
   * @type {Array<InlineResponse20042Rows>}
   * @memberof DataListResponse
   */
  rows?: Array<InlineResponse20042Rows>;
}
/**
 *
 * @export
 * @interface DataPersistResponse
 */
export interface DataPersistResponse {
  /**
   *
   * @type {string}
   * @memberof DataPersistResponse
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DataPersistResponse
   */
  rev?: string;
}
/**
 *
 * @export
 * @interface DistrconfigActivatePoolRequest
 */
export interface DistrconfigActivatePoolRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigActivatePoolRequest
   */
  id?: string;
}
/**
 *
 * @export
 * @interface DistrconfigAssignAppToUsersRequest
 */
export interface DistrconfigAssignAppToUsersRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignAppToUsersRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignAppToUsersRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignAppToUsersResponse
 */
export interface DistrconfigAssignAppToUsersResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignAppToUsersResponse
   */
  failedUserIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignPoolsToAppRequest
 */
export interface DistrconfigAssignPoolsToAppRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignPoolsToAppRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignPoolsToAppRequest
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignPoolsToAppResponse
 */
export interface DistrconfigAssignPoolsToAppResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigAssignPoolsToAppResponse
   */
  failedPoolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigAssignTagToUserRequest
 */
export interface DistrconfigAssignTagToUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigAssignTagToUserRequest
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface DistrconfigCreatePoolsRequest
 */
export interface DistrconfigCreatePoolsRequest {
  /**
   *
   * @type {Array<InlineObject41>}
   * @memberof DistrconfigCreatePoolsRequest
   */
  dataPools?: Array<InlineObject41>;
}
/**
 *
 * @export
 * @interface DistrconfigCreateUserRequest
 */
export interface DistrconfigCreateUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigCreateUserRequest
   */
  id?: string;
}
/**
 *
 * @export
 * @interface DistrconfigDataPool
 */
export interface DistrconfigDataPool {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  poolType?: DistrconfigDataPoolPoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigDataPool
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPool
   */
  onUploadFunction?: string;
}

export const DistrconfigDataPoolPoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type DistrconfigDataPoolPoolTypeEnum = typeof DistrconfigDataPoolPoolTypeEnum[keyof typeof DistrconfigDataPoolPoolTypeEnum];

/**
 *
 * @export
 * @interface DistrconfigDataPoolShort
 */
export interface DistrconfigDataPoolShort {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPoolShort
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDataPoolShort
   */
  poolType?: DistrconfigDataPoolShortPoolTypeEnum;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigDataPoolShort
   */
  active?: boolean;
}

export const DistrconfigDataPoolShortPoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type DistrconfigDataPoolShortPoolTypeEnum = typeof DistrconfigDataPoolShortPoolTypeEnum[keyof typeof DistrconfigDataPoolShortPoolTypeEnum];

/**
 *
 * @export
 * @interface DistrconfigDistributionUser
 */
export interface DistrconfigDistributionUser {
  /**
   *
   * @type {string}
   * @memberof DistrconfigDistributionUser
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigDistributionUser
   */
  activeAppID?: string;
  /**
   *
   * @type {Array<InlineResponse20040UserTagAssignments>}
   * @memberof DistrconfigDistributionUser
   */
  tagAssignments?: Array<InlineResponse20040UserTagAssignments>;
}
/**
 *
 * @export
 * @interface DistrconfigGetAppResponse
 */
export interface DistrconfigGetAppResponse {
  /**
   *
   * @type {InlineResponse20036App}
   * @memberof DistrconfigGetAppResponse
   */
  app?: InlineResponse20036App;
}
/**
 *
 * @export
 * @interface DistrconfigGetAppsResponse
 */
export interface DistrconfigGetAppsResponse {
  /**
   *
   * @type {Array<InlineResponse20036App>}
   * @memberof DistrconfigGetAppsResponse
   */
  apps?: Array<InlineResponse20036App>;
}
/**
 *
 * @export
 * @interface DistrconfigGetPoolDistributionResponse
 */
export interface DistrconfigGetPoolDistributionResponse {
  /**
   *
   * @type {string}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  dbUrl?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  poolType?: DistrconfigGetPoolDistributionResponsePoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof DistrconfigGetPoolDistributionResponse
   */
  tagPrefix?: string;
}

export const DistrconfigGetPoolDistributionResponsePoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type DistrconfigGetPoolDistributionResponsePoolTypeEnum = typeof DistrconfigGetPoolDistributionResponsePoolTypeEnum[keyof typeof DistrconfigGetPoolDistributionResponsePoolTypeEnum];

/**
 *
 * @export
 * @interface DistrconfigGetPoolResponse
 */
export interface DistrconfigGetPoolResponse {
  /**
   *
   * @type {InlineObject41}
   * @memberof DistrconfigGetPoolResponse
   */
  dataPool?: InlineObject41;
}
/**
 *
 * @export
 * @interface DistrconfigGetPoolsResponse
 */
export interface DistrconfigGetPoolsResponse {
  /**
   *
   * @type {Array<ContainsListOfAllDataPoolTasksDataPool>}
   * @memberof DistrconfigGetPoolsResponse
   */
  dataPool?: Array<ContainsListOfAllDataPoolTasksDataPool>;
  /**
   *
   * @type {{ [key: string]: ContainsListOfAllDataPoolTasksPoolSizes; }}
   * @memberof DistrconfigGetPoolsResponse
   */
  poolSizes?: { [key: string]: ContainsListOfAllDataPoolTasksPoolSizes };
}
/**
 *
 * @export
 * @interface DistrconfigGetUserResponse
 */
export interface DistrconfigGetUserResponse {
  /**
   *
   * @type {InlineResponse20040User}
   * @memberof DistrconfigGetUserResponse
   */
  user?: InlineResponse20040User;
}
/**
 *
 * @export
 * @interface DistrconfigGetUsersResponse
 */
export interface DistrconfigGetUsersResponse {
  /**
   *
   * @type {Array<InlineResponse20040User>}
   * @memberof DistrconfigGetUsersResponse
   */
  users?: Array<InlineResponse20040User>;
}
/**
 *
 * @export
 * @interface DistrconfigMobileApp
 */
export interface DistrconfigMobileApp {
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileApp
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileApp
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigMobileApp
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface DistrconfigMobileAppWithPools
 */
export interface DistrconfigMobileAppWithPools {
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileAppWithPools
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigMobileAppWithPools
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof DistrconfigMobileAppWithPools
   */
  active?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigMobileAppWithPools
   */
  assignedPools?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigPoolSize
 */
export interface DistrconfigPoolSize {
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  globalDataSizeBytes?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigPoolSize
   */
  userDataSizeBytes?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const DistrconfigPoolType = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type DistrconfigPoolType = typeof DistrconfigPoolType[keyof typeof DistrconfigPoolType];

/**
 *
 * @export
 * @interface DistrconfigUnassignAppFromUsersRequest
 */
export interface DistrconfigUnassignAppFromUsersRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignAppFromUsersRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignAppFromUsersRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignAppFromUsersResponse
 */
export interface DistrconfigUnassignAppFromUsersResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignAppFromUsersResponse
   */
  failedUserIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignPoolsFromAppRequest
 */
export interface DistrconfigUnassignPoolsFromAppRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignPoolsFromAppRequest
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignPoolsFromAppRequest
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignPoolsFromAppResponse
 */
export interface DistrconfigUnassignPoolsFromAppResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigUnassignPoolsFromAppResponse
   */
  failedPoolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface DistrconfigUnassignTagFromUserRequest
 */
export interface DistrconfigUnassignTagFromUserRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUnassignTagFromUserRequest
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface DistrconfigUserTagAssignment
 */
export interface DistrconfigUserTagAssignment {
  /**
   *
   * @type {string}
   * @memberof DistrconfigUserTagAssignment
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigUserTagAssignment
   */
  value?: string;
}
/**
 *
 * @export
 * @interface DistrconfigValidatePoolDataRequest
 */
export interface DistrconfigValidatePoolDataRequest {
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  poolType?: DistrconfigValidatePoolDataRequestPoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataRequest
   */
  data?: string;
}

export const DistrconfigValidatePoolDataRequestPoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type DistrconfigValidatePoolDataRequestPoolTypeEnum = typeof DistrconfigValidatePoolDataRequestPoolTypeEnum[keyof typeof DistrconfigValidatePoolDataRequestPoolTypeEnum];

/**
 *
 * @export
 * @interface DistrconfigValidatePoolDataResponse
 */
export interface DistrconfigValidatePoolDataResponse {
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  derivedPk?: string;
  /**
   *
   * @type {string}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  derivedTag?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof DistrconfigValidatePoolDataResponse
   */
  validationErrors?: Array<string>;
}
/**
 *
 * @export
 * @interface FunctionsCallAsyncFunctionRequest
 */
export interface FunctionsCallAsyncFunctionRequest {
  /**
   *
   * @type {FunctionsCallAsyncFunctionRequestCall}
   * @memberof FunctionsCallAsyncFunctionRequest
   */
  call?: FunctionsCallAsyncFunctionRequestCall;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallAsyncFunctionRequest
   */
  reason?: string;
}
/**
 *
 * @export
 * @interface FunctionsCallAsyncFunctionRequestCall
 */
export interface FunctionsCallAsyncFunctionRequestCall {
  /**
   *
   * @type {string}
   * @memberof FunctionsCallAsyncFunctionRequestCall
   */
  id?: string;
  /**
   *
   * @type {object}
   * @memberof FunctionsCallAsyncFunctionRequestCall
   */
  payload?: object;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallAsyncFunctionRequestCall
   */
  payloadJSON?: string;
}
/**
 *
 * @export
 * @interface FunctionsCallFunctionRequest
 */
export interface FunctionsCallFunctionRequest {
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionRequest
   */
  id?: string;
  /**
   *
   * @type {object}
   * @memberof FunctionsCallFunctionRequest
   */
  payload?: object;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionRequest
   */
  payloadJSON?: string;
}
/**
 *
 * @export
 * @interface FunctionsCallFunctionResponse
 */
export interface FunctionsCallFunctionResponse {
  /**
   *
   * @type {boolean}
   * @memberof FunctionsCallFunctionResponse
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof FunctionsCallFunctionResponse
   */
  err?: string;
  /**
   *
   * @type {object}
   * @memberof FunctionsCallFunctionResponse
   */
  body?: object;
}
/**
 *
 * @export
 * @interface FunctionsCaller
 */
export interface FunctionsCaller {
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCaller
   */
  policies?: string;
}
/**
 *
 * @export
 * @interface FunctionsCreateFunctionRequest
 */
export interface FunctionsCreateFunctionRequest {
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionRequest
   */
  config?: string;
}
/**
 *
 * @export
 * @interface FunctionsCreateFunctionResponse
 */
export interface FunctionsCreateFunctionResponse {
  /**
   *
   * @type {string}
   * @memberof FunctionsCreateFunctionResponse
   */
  id?: string;
}
/**
 *
 * @export
 * @interface FunctionsFunction
 */
export interface FunctionsFunction {
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof FunctionsFunction
   */
  config?: string;
}
/**
 *
 * @export
 * @interface FunctionsGetFunctionResponse
 */
export interface FunctionsGetFunctionResponse {
  /**
   *
   * @type {InlineObject30}
   * @memberof FunctionsGetFunctionResponse
   */
  function?: InlineObject30;
  /**
   *
   * @type {InlineObject30}
   * @memberof FunctionsGetFunctionResponse
   */
  result?: InlineObject30;
}
/**
 *
 * @export
 * @interface FunctionsGetFunctionsResponse
 */
export interface FunctionsGetFunctionsResponse {
  /**
   *
   * @type {Array<InlineObject30>}
   * @memberof FunctionsGetFunctionsResponse
   */
  functions?: Array<InlineObject30>;
}
/**
 *
 * @export
 * @interface GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterThe
 */
export interface GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterThe {
  /**
   *
   * @type {Array<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels>}
   * @memberof GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterThe
   */
  loglabels?: Array<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels>;
}
/**
 * LabelValues contain a list of all possible values per label name.
 * @export
 * @interface GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels
 */
export interface GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels {
  /**
   *
   * @type {string}
   * @memberof GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels
   */
  values?: Array<string>;
}
/**
 * The QueryLogsRequest contains all parameters for searching for log entries inside the appscape log store. Those parameters will filter the logs that will be retrieved to only provide entries that macht the values in the  request.
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  timeTill?: string;
  /**
   *
   * @type {number}
   * @memberof InlineObject
   */
  limit?: number;
  /**
   *
   * @type {Array<ApiAppscapeV1LogsQueryLabels>}
   * @memberof InlineObject
   */
  labels?: Array<ApiAppscapeV1LogsQueryLabels>;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  match?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject
   */
  notMatch?: string;
}
/**
 * The QueryMetricsRequest is used to retrieve data for a specific metric in a time period. Additionally, filters can be provided to only retrieve data points for a certain label, as well as aggregations, that can be used to  get a summary over the underlying data.
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  metric?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  timeTill?: string;
  /**
   *
   * @type {Array<ApiAppscapeV1MetricsQueryFilters>}
   * @memberof InlineObject1
   */
  filters?: Array<ApiAppscapeV1MetricsQueryFilters>;
  /**
   *
   * @type {Array<ApiAppscapeV1MetricsQueryAggregations>}
   * @memberof InlineObject1
   */
  aggregations?: Array<ApiAppscapeV1MetricsQueryAggregations>;
}
/**
 *
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
  /**
   *
   * @type {string}
   * @memberof InlineObject10
   */
  suffix?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject10
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject10
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject10
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
  /**
   *
   * @type {string}
   * @memberof InlineObject11
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject11
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject11
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
  /**
   *
   * @type {string}
   * @memberof InlineObject12
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  fedType?: InlineObject13FedTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject13
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject13
   */
  oidcUseSecret?: boolean;
}

export const InlineObject13FedTypeEnum = {
  Oidc: 'Oidc',
} as const;

export type InlineObject13FedTypeEnum = typeof InlineObject13FedTypeEnum[keyof typeof InlineObject13FedTypeEnum];

/**
 *
 * @export
 * @interface InlineObject14
 */
export interface InlineObject14 {
  /**
   *
   * @type {InlineResponse20010Policies}
   * @memberof InlineObject14
   */
  policy?: InlineResponse20010Policies;
}
/**
 *
 * @export
 * @interface InlineObject15
 */
export interface InlineObject15 {
  /**
   *
   * @type {InlineResponse20010Policies}
   * @memberof InlineObject15
   */
  policy?: InlineResponse20010Policies;
}
/**
 *
 * @export
 * @interface InlineObject16
 */
export interface InlineObject16 {
  /**
   *
   * @type {string}
   * @memberof InlineObject16
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface InlineObject17
 */
export interface InlineObject17 {
  /**
   *
   * @type {ApiAuthV1RoleRole}
   * @memberof InlineObject17
   */
  role?: ApiAuthV1RoleRole;
}
/**
 *
 * @export
 * @interface InlineObject18
 */
export interface InlineObject18 {
  /**
   *
   * @type {string}
   * @memberof InlineObject18
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject18
   */
  description?: string;
}
/**
 *
 * @export
 * @interface InlineObject19
 */
export interface InlineObject19 {
  /**
   *
   * @type {string}
   * @memberof InlineObject19
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject19
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {string}
   * @memberof InlineObject2
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface InlineObject20
 */
export interface InlineObject20 {
  /**
   *
   * @type {string}
   * @memberof InlineObject20
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject20
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject21
 */
export interface InlineObject21 {
  /**
   *
   * @type {string}
   * @memberof InlineObject21
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject21
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject22
 */
export interface InlineObject22 {
  /**
   *
   * @type {string}
   * @memberof InlineObject22
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject22
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject23
 */
export interface InlineObject23 {
  /**
   *
   * @type {string}
   * @memberof InlineObject23
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject23
   */
  userPassword?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject23
   */
  newPassword?: string;
}
/**
 *
 * @export
 * @interface InlineObject24
 */
export interface InlineObject24 {
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  federationID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject24
   */
  phoneNumber?: string;
}
/**
 *
 * @export
 * @interface InlineObject25
 */
export interface InlineObject25 {
  /**
   *
   * @type {string}
   * @memberof InlineObject25
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject25
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject26
 */
export interface InlineObject26 {
  /**
   *
   * @type {string}
   * @memberof InlineObject26
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject26
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject27
 */
export interface InlineObject27 {
  /**
   *
   * @type {ApiAuthV1UserUserUserIDUser}
   * @memberof InlineObject27
   */
  user?: ApiAuthV1UserUserUserIDUser;
}
/**
 *
 * @export
 * @interface InlineObject28
 */
export interface InlineObject28 {
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject28
   */
  config?: string;
}
/**
 *
 * @export
 * @interface InlineObject29
 */
export interface InlineObject29 {
  /**
   *
   * @type {string}
   * @memberof InlineObject29
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject29
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject29
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject29
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject29
   */
  config?: string;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   *
   * @type {string}
   * @memberof InlineObject3
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject3
   */
  description?: string;
  /**
   *
   * @type {InlineResponse2004AccountPaymentDetails}
   * @memberof InlineObject3
   */
  paymentDetails?: InlineResponse2004AccountPaymentDetails;
  /**
   *
   * @type {InlineResponse2004AccountContactDetails}
   * @memberof InlineObject3
   */
  contactDetails?: InlineResponse2004AccountContactDetails;
}
/**
 *
 * @export
 * @interface InlineObject30
 */
export interface InlineObject30 {
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  funcType?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  endpoint?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  region?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject30
   */
  config?: string;
}
/**
 *
 * @export
 * @interface InlineObject31
 */
export interface InlineObject31 {
  /**
   *
   * @type {string}
   * @memberof InlineObject31
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject31
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject31
   */
  active?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject32
 */
export interface InlineObject32 {
  /**
   *
   * @type {string}
   * @memberof InlineObject32
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject32
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject33
 */
export interface InlineObject33 {
  /**
   *
   * @type {string}
   * @memberof InlineObject33
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject33
   */
  poolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject34
 */
export interface InlineObject34 {
  /**
   *
   * @type {string}
   * @memberof InlineObject34
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject34
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject35
 */
export interface InlineObject35 {
  /**
   *
   * @type {string}
   * @memberof InlineObject35
   */
  appID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject35
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject36
 */
export interface InlineObject36 {
  /**
   *
   * @type {string}
   * @memberof InlineObject36
   */
  bundleUrl?: string;
}
/**
 *
 * @export
 * @interface InlineObject37
 */
export interface InlineObject37 {
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  poolType?: InlineObject37PoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject37
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject37
   */
  onUploadFunction?: string;
}

export const InlineObject37PoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type InlineObject37PoolTypeEnum = typeof InlineObject37PoolTypeEnum[keyof typeof InlineObject37PoolTypeEnum];

/**
 *
 * @export
 * @interface InlineObject38
 */
export interface InlineObject38 {
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  poolType?: InlineObject38PoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject38
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject38
   */
  onUploadFunction?: string;
}

export const InlineObject38PoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type InlineObject38PoolTypeEnum = typeof InlineObject38PoolTypeEnum[keyof typeof InlineObject38PoolTypeEnum];

/**
 *
 * @export
 * @interface InlineObject39
 */
export interface InlineObject39 {
  /**
   *
   * @type {string}
   * @memberof InlineObject39
   */
  id?: string;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   *
   * @type {InlineResponse2004Account}
   * @memberof InlineObject4
   */
  account?: InlineResponse2004Account;
}
/**
 *
 * @export
 * @interface InlineObject40
 */
export interface InlineObject40 {
  /**
   *
   * @type {string}
   * @memberof InlineObject40
   */
  poolType?: InlineObject40PoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineObject40
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject40
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject40
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject40
   */
  data?: string;
}

export const InlineObject40PoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type InlineObject40PoolTypeEnum = typeof InlineObject40PoolTypeEnum[keyof typeof InlineObject40PoolTypeEnum];

/**
 *
 * @export
 * @interface InlineObject41
 */
export interface InlineObject41 {
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  poolType?: InlineObject41PoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  pkExtractExpression?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  tagExtractExpression?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject41
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  schema?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject41
   */
  onUploadFunction?: string;
}

export const InlineObject41PoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type InlineObject41PoolTypeEnum = typeof InlineObject41PoolTypeEnum[keyof typeof InlineObject41PoolTypeEnum];

/**
 *
 * @export
 * @interface InlineObject42
 */
export interface InlineObject42 {
  /**
   *
   * @type {Array<InlineObject41>}
   * @memberof InlineObject42
   */
  dataPools?: Array<InlineObject41>;
}
/**
 *
 * @export
 * @interface InlineObject43
 */
export interface InlineObject43 {
  /**
   *
   * @type {string}
   * @memberof InlineObject43
   */
  id?: string;
}
/**
 *
 * @export
 * @interface InlineObject44
 */
export interface InlineObject44 {
  /**
   *
   * @type {string}
   * @memberof InlineObject44
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject44
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject44
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface InlineObject45
 */
export interface InlineObject45 {
  /**
   *
   * @type {string}
   * @memberof InlineObject45
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject45
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject45
   */
  tagValue?: string;
}
/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   *
   * @type {string}
   * @memberof InlineObject5
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
  /**
   *
   * @type {string}
   * @memberof InlineObject6
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  httpMethod?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  requestPath?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  contentType?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  md5Body?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject7
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
  /**
   *
   * @type {string}
   * @memberof InlineObject8
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject8
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject8
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
  /**
   *
   * @type {string}
   * @memberof InlineObject9
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject9
   */
  userID?: string;
}
/**
 * QueryLogsResponse contains a list of log entries that match the request  parameters.
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   *
   * @type {Array<InlineResponse200Logs>}
   * @memberof InlineResponse200
   */
  logs?: Array<InlineResponse200Logs>;
}
/**
 * GetMetricsMetaResponse contains a list of metric meta objects, describing all metrics that are currently available in the system.
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   *
   * @type {Array<InlineResponse2001Metrics>}
   * @memberof InlineResponse2001
   */
  metrics?: Array<InlineResponse2001Metrics>;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {Array<InlineResponse20010Policies>}
   * @memberof InlineResponse20010
   */
  policies?: Array<InlineResponse20010Policies>;
}
/**
 *
 * @export
 * @interface InlineResponse20010Actions
 */
export interface InlineResponse20010Actions {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010Actions
   */
  service?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010Actions
   */
  call?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20010Permissions
 */
export interface InlineResponse20010Permissions {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010Permissions
   */
  effect?: string;
  /**
   *
   * @type {Array<InlineResponse20010Actions>}
   * @memberof InlineResponse20010Permissions
   */
  actions?: Array<InlineResponse20010Actions>;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20010Permissions
   */
  scope?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20010Policies
 */
export interface InlineResponse20010Policies {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010Policies
   */
  policyID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20010Policies
   */
  name?: string;
  /**
   *
   * @type {Array<InlineResponse20010Permissions>}
   * @memberof InlineResponse20010Policies
   */
  permissions?: Array<InlineResponse20010Permissions>;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   *
   * @type {InlineResponse20011Config}
   * @memberof InlineResponse20011
   */
  config?: InlineResponse20011Config;
}
/**
 *
 * @export
 * @interface InlineResponse20011Config
 */
export interface InlineResponse20011Config {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  fedID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  fedType?: InlineResponse20011ConfigFedTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011Config
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20011Config
   */
  oidcUseSecret?: boolean;
}

export const InlineResponse20011ConfigFedTypeEnum = {
  Oidc: 'Oidc',
} as const;

export type InlineResponse20011ConfigFedTypeEnum = typeof InlineResponse20011ConfigFedTypeEnum[keyof typeof InlineResponse20011ConfigFedTypeEnum];

/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof InlineResponse20012
   */
  roles?: Array<AccountRoles>;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
  /**
   *
   * @type {InlineResponse20013Policy}
   * @memberof InlineResponse20013
   */
  policy?: InlineResponse20013Policy;
}
/**
 *
 * @export
 * @interface InlineResponse20013Policy
 */
export interface InlineResponse20013Policy {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013Policy
   */
  minLength?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20013Policy
   */
  useLowerLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20013Policy
   */
  useUpperLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20013Policy
   */
  useNumbers?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20013Policy
   */
  useSpecialCharecters?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20014
   */
  policyID?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20015
   */
  roleID?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20016
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20017
   */
  failedUserIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20017
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20018
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
  /**
   *
   * @type {InlineResponse20019Role}
   * @memberof InlineResponse20019
   */
  role?: InlineResponse20019Role;
}
/**
 *
 * @export
 * @interface InlineResponse20019Role
 */
export interface InlineResponse20019Role {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Role
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Role
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Role
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20019Role
   */
  policyIDs?: Array<string>;
}
/**
 * MetricMeta contains a name of a metric and a short description, indicating what this metric is representing.
 * @export
 * @interface InlineResponse2001Metrics
 */
export interface InlineResponse2001Metrics {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001Metrics
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2001Metrics
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse2001Metrics
   */
  labels?: Array<string>;
}
/**
 * QueryMetricsResponse contains a list of metrics series objects that hold  data for the respecive metrics, which matches the parameters provided in  the query request.
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {Array<InlineResponse2002Metrics>}
   * @memberof InlineResponse2002
   */
  metrics?: Array<InlineResponse2002Metrics>;
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
  /**
   *
   * @type {Array<InlineResponse20019Role>}
   * @memberof InlineResponse20020
   */
  roles?: Array<InlineResponse20019Role>;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
  /**
   *
   * @type {Array<InlineResponse2004Account>}
   * @memberof InlineResponse20021
   */
  accounts?: Array<InlineResponse2004Account>;
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
  /**
   *
   * @type {Array<InlineResponse20022Keys>}
   * @memberof InlineResponse20022
   */
  keys?: Array<InlineResponse20022Keys>;
}
/**
 *
 * @export
 * @interface InlineResponse20022Keys
 */
export interface InlineResponse20022Keys {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20022Keys
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20022Keys
   */
  lastUsedAt?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
  /**
   *
   * @type {InlineResponse20023User}
   * @memberof InlineResponse20023
   */
  user?: InlineResponse20023User;
}
/**
 *
 * @export
 * @interface InlineResponse20023User
 */
export interface InlineResponse20023User {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  lastLogin?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20023User
   */
  policyIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20023User
   */
  roleIDs?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20023User
   */
  federationID?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
  /**
   *
   * @type {InlineResponse20024UserInfo}
   * @memberof InlineResponse20024
   */
  userInfo?: InlineResponse20024UserInfo;
}
/**
 *
 * @export
 * @interface InlineResponse20024UserInfo
 */
export interface InlineResponse20024UserInfo {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  name?: string;
  /**
   *
   * @type {Array<InlineResponse20010Policies>}
   * @memberof InlineResponse20024UserInfo
   */
  policies?: Array<InlineResponse20010Policies>;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  logoutUrl?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  assumedAccountID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20024UserInfo
   */
  language?: string;
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof InlineResponse20024UserInfo
   */
  accountRoles?: Array<AccountRoles>;
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20025
   */
  totalRows?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20025
   */
  offset?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20025
   */
  limit?: number;
  /**
   *
   * @type {Array<InlineResponse20023User>}
   * @memberof InlineResponse20025
   */
  users?: Array<InlineResponse20023User>;
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
  /**
   *
   * @type {InlineResponse20026Subscription}
   * @memberof InlineResponse20026
   */
  subscription?: InlineResponse20026Subscription;
}
/**
 *
 * @export
 * @interface InlineResponse20026Subscription
 */
export interface InlineResponse20026Subscription {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  currentPeriodStart?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  currentPeriodEnd?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  canceledAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20026Subscription
   */
  cancelAtPeriodEnd?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026Subscription
   */
  clientSecret?: string;
  /**
   *
   * @type {InlineResponse20026SubscriptionSubscriptionItem}
   * @memberof InlineResponse20026Subscription
   */
  subscriptionItem?: InlineResponse20026SubscriptionSubscriptionItem;
}
/**
 *
 * @export
 * @interface InlineResponse20026SubscriptionSubscriptionItem
 */
export interface InlineResponse20026SubscriptionSubscriptionItem {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItem
   */
  created?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20026SubscriptionSubscriptionItem
   */
  quantity?: number;
  /**
   *
   * @type {InlineResponse20026SubscriptionSubscriptionItemPrice}
   * @memberof InlineResponse20026SubscriptionSubscriptionItem
   */
  price?: InlineResponse20026SubscriptionSubscriptionItemPrice;
}
/**
 *
 * @export
 * @interface InlineResponse20026SubscriptionSubscriptionItemPrice
 */
export interface InlineResponse20026SubscriptionSubscriptionItemPrice {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItemPrice
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20026SubscriptionSubscriptionItemPrice
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItemPrice
   */
  billingScheme?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItemPrice
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20026SubscriptionSubscriptionItemPrice
   */
  currency?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20027
   */
  clientSecret?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20028
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20028
   */
  clientSecret?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
  /**
   *
   * @type {InlineResponse20029SubscriptionStatus}
   * @memberof InlineResponse20029
   */
  subscriptionStatus?: InlineResponse20029SubscriptionStatus;
  /**
   *
   * @type {InlineResponse20029BillingData}
   * @memberof InlineResponse20029
   */
  billingData?: InlineResponse20029BillingData;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20029
   */
  hasSetupPayment?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20029
   */
  hasSetupSubscription?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20029BillingData
 */
export interface InlineResponse20029BillingData {
  /**
   *
   * @type {InlineResponse20029BillingDataAddress}
   * @memberof InlineResponse20029BillingData
   */
  address?: InlineResponse20029BillingDataAddress;
  /**
   *
   * @type {InlineResponse20029BillingDataTaxIDData}
   * @memberof InlineResponse20029BillingData
   */
  taxIDData?: InlineResponse20029BillingDataTaxIDData;
}
/**
 *
 * @export
 * @interface InlineResponse20029BillingDataAddress
 */
export interface InlineResponse20029BillingDataAddress {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  line1?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  line2?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  postalCode?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataAddress
   */
  state?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029BillingDataTaxIDData
 */
export interface InlineResponse20029BillingDataTaxIDData {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataTaxIDData
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029BillingDataTaxIDData
   */
  value?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029SubscriptionStatus
 */
export interface InlineResponse20029SubscriptionStatus {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  priceID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  productDescription?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  customerID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  cardBrand?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  cardLast4?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  nextAmmountDue?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  nextPaymentDate?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  lastAmountPaid?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  lastInvoiceDescription?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  clientSecret?: string;
  /**
   *
   * @type {Array<InlineResponse20029SubscriptionStatusInvoiceItems>}
   * @memberof InlineResponse20029SubscriptionStatus
   */
  invoiceItems?: Array<InlineResponse20029SubscriptionStatusInvoiceItems>;
}
/**
 *
 * @export
 * @interface InlineResponse20029SubscriptionStatusInvoiceItems
 */
export interface InlineResponse20029SubscriptionStatusInvoiceItems {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatusInvoiceItems
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatusInvoiceItems
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatusInvoiceItems
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029SubscriptionStatusInvoiceItems
   */
  quantity?: string;
}
/**
 * A DataPoint represents a single data point in a metrics series and consists  of a timestamp and the value for the metric at the specific time.
 * @export
 * @interface InlineResponse2002Data
 */
export interface InlineResponse2002Data {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Data
   */
  t?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2002Data
   */
  v?: number;
}
/**
 * MetricSeries contains the data for a single metric for a requested time span. The object contains both the labels for the result, as well as the actual  data points.
 * @export
 * @interface InlineResponse2002Metrics
 */
export interface InlineResponse2002Metrics {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2002Metrics
   */
  name?: string;
  /**
   *
   * @type {Array<ApiAppscapeV1LogsQueryLabels>}
   * @memberof InlineResponse2002Metrics
   */
  labels?: Array<ApiAppscapeV1LogsQueryLabels>;
  /**
   *
   * @type {Array<InlineResponse2002Data>}
   * @memberof InlineResponse2002Metrics
   */
  data?: Array<InlineResponse2002Data>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003
   */
  accessSecret?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20030
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20030
   */
  err?: string;
  /**
   *
   * @type {object}
   * @memberof InlineResponse20030
   */
  body?: object;
}
/**
 *
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20031
   */
  id?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
  /**
   *
   * @type {InlineObject30}
   * @memberof InlineResponse20032
   */
  function?: InlineObject30;
  /**
   *
   * @type {InlineObject30}
   * @memberof InlineResponse20032
   */
  result?: InlineObject30;
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
  /**
   *
   * @type {Array<InlineObject30>}
   * @memberof InlineResponse20033
   */
  functions?: Array<InlineObject30>;
}
/**
 *
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20034
   */
  failedPoolIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20035
   */
  failedUserIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
  /**
   *
   * @type {InlineResponse20036App}
   * @memberof InlineResponse20036
   */
  app?: InlineResponse20036App;
}
/**
 *
 * @export
 * @interface InlineResponse20036App
 */
export interface InlineResponse20036App {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20036App
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20036App
   */
  bundleUrl?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20036App
   */
  active?: boolean;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20036App
   */
  assignedPools?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
  /**
   *
   * @type {Array<InlineResponse20036App>}
   * @memberof InlineResponse20037
   */
  apps?: Array<InlineResponse20036App>;
}
/**
 *
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20038
   */
  dbUrl?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20038
   */
  poolType?: InlineResponse20038PoolTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20038
   */
  tagPrefix?: string;
}

export const InlineResponse20038PoolTypeEnum = {
  Unknown: 'UNKNOWN',
  Global: 'GLOBAL',
  Filtered: 'FILTERED',
  User: 'USER',
} as const;

export type InlineResponse20038PoolTypeEnum = typeof InlineResponse20038PoolTypeEnum[keyof typeof InlineResponse20038PoolTypeEnum];

/**
 *
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20039
   */
  derivedPk?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20039
   */
  derivedTag?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20039
   */
  validationErrors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   *
   * @type {InlineResponse2004Account}
   * @memberof InlineResponse2004
   */
  account?: InlineResponse2004Account;
}
/**
 *
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
  /**
   *
   * @type {InlineResponse20040User}
   * @memberof InlineResponse20040
   */
  user?: InlineResponse20040User;
}
/**
 *
 * @export
 * @interface InlineResponse20040User
 */
export interface InlineResponse20040User {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20040User
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20040User
   */
  activeAppID?: string;
  /**
   *
   * @type {Array<InlineResponse20040UserTagAssignments>}
   * @memberof InlineResponse20040User
   */
  tagAssignments?: Array<InlineResponse20040UserTagAssignments>;
}
/**
 *
 * @export
 * @interface InlineResponse20040UserTagAssignments
 */
export interface InlineResponse20040UserTagAssignments {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20040UserTagAssignments
   */
  poolID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20040UserTagAssignments
   */
  value?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
  /**
   *
   * @type {Array<InlineResponse20040User>}
   * @memberof InlineResponse20041
   */
  users?: Array<InlineResponse20040User>;
}
/**
 *
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
  /**
   * The number of rows in the database
   * @type {number}
   * @memberof InlineResponse20042
   */
  total_rows?: number;
  /**
   * Current offset
   * @type {number}
   * @memberof InlineResponse20042
   */
  offset?: number;
  /**
   *
   * @type {Array<InlineResponse20042Rows>}
   * @memberof InlineResponse20042
   */
  rows?: Array<InlineResponse20042Rows>;
}
/**
 *
 * @export
 * @interface InlineResponse20042Rows
 */
export interface InlineResponse20042Rows {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20042Rows
   */
  _id: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20042Rows
   */
  _rev?: string;
  /**
   * Optional field for USER and FILTERED pools.
   * @type {Array<string>}
   * @memberof InlineResponse20042Rows
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
  /**
   * Successful creation
   * @type {Array<InlineResponse20043Result>}
   * @memberof InlineResponse20043
   */
  result?: Array<InlineResponse20043Result>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof InlineResponse20043
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20043Result
 */
export interface InlineResponse20043Result {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20043Result
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20043Result
   */
  rev?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
  /**
   * Successful deletion
   * @type {Array<InlineResponse20043Result>}
   * @memberof InlineResponse20044
   */
  result?: Array<InlineResponse20043Result>;
  /**
   * List of errors if any occur
   * @type {Array<string>}
   * @memberof InlineResponse20044
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse2004Account
 */
export interface InlineResponse2004Account {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004Account
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004Account
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004Account
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004Account
   */
  status?: InlineResponse2004AccountStatusEnum;
  /**
   *
   * @type {InlineResponse2004AccountPaymentDetails}
   * @memberof InlineResponse2004Account
   */
  paymentDetails?: InlineResponse2004AccountPaymentDetails;
  /**
   *
   * @type {InlineResponse2004AccountContactDetails}
   * @memberof InlineResponse2004Account
   */
  contactDetails?: InlineResponse2004AccountContactDetails;
}

export const InlineResponse2004AccountStatusEnum = {
  Pending: 'PENDING',
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Deleted: 'DELETED',
} as const;

export type InlineResponse2004AccountStatusEnum = typeof InlineResponse2004AccountStatusEnum[keyof typeof InlineResponse2004AccountStatusEnum];

/**
 *
 * @export
 * @interface InlineResponse2004AccountContactDetails
 */
export interface InlineResponse2004AccountContactDetails {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004AccountContactDetails
   */
  main?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004AccountContactDetails
   */
  finance?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004AccountContactDetails
   */
  technical?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2004AccountPaymentDetails
 */
export interface InlineResponse2004AccountPaymentDetails {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004AccountPaymentDetails
   */
  type?: InlineResponse2004AccountPaymentDetailsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2004AccountPaymentDetails
   */
  info?: string;
}

export const InlineResponse2004AccountPaymentDetailsTypeEnum = {
  CreditCard: 'CreditCard',
  Paypal: 'Paypal',
  DirectDebig: 'DirectDebig',
  Invoice: 'Invoice',
} as const;

export type InlineResponse2004AccountPaymentDetailsTypeEnum = typeof InlineResponse2004AccountPaymentDetailsTypeEnum[keyof typeof InlineResponse2004AccountPaymentDetailsTypeEnum];

/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2005
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2006
   */
  error?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  exists?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   *
   * @type {InlineResponse2008Client}
   * @memberof InlineResponse2008
   */
  client?: InlineResponse2008Client;
}
/**
 *
 * @export
 * @interface InlineResponse2008Client
 */
export interface InlineResponse2008Client {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008Client
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008Client
   */
  secret?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008Client
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008Client
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse2008Client
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   *
   * @type {Array<InlineResponse2008Client>}
   * @memberof InlineResponse2009
   */
  client?: Array<InlineResponse2008Client>;
}
/**
 * A log entry field represents one single attribute of the log entry, which consists of a name and value pair and is not part of the default structure of log messages.
 * @export
 * @interface InlineResponse200Fields
 */
export interface InlineResponse200Fields {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Fields
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Fields
   */
  value?: string;
}
/**
 * LogEntry is a single log messsage which consists of a set of fields or  attributes, some of which are available to all messages, and others are  specific to the event that created the message.
 * @export
 * @interface InlineResponse200Logs
 */
export interface InlineResponse200Logs {
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  logId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  time?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  severity?: InlineResponse200LogsSeverityEnum;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse200Logs
   */
  action?: string;
  /**
   *
   * @type {Array<InlineResponse200Fields>}
   * @memberof InlineResponse200Logs
   */
  fields?: Array<InlineResponse200Fields>;
}

export const InlineResponse200LogsSeverityEnum = {
  Unknown: 'UNKNOWN',
  Trace: 'TRACE',
  Info: 'INFO',
  Warning: 'WARNING',
  Error: 'ERROR',
  Audit: 'AUDIT',
  All: 'ALL',
} as const;

export type InlineResponse200LogsSeverityEnum = typeof InlineResponse200LogsSeverityEnum[keyof typeof InlineResponse200LogsSeverityEnum];

/**
 *
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
  /**
   *
   * @type {number}
   * @memberof InlineResponseDefault
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponseDefault
   */
  message?: string;
  /**
   *
   * @type {Array<{ [key: string]: object; }>}
   * @memberof InlineResponseDefault
   */
  details?: Array<{ [key: string]: object }>;
}
/**
 *
 * @export
 * @enum {string}
 */

export const LogEntrySeverity = {
  Unknown: 'UNKNOWN',
  Trace: 'TRACE',
  Info: 'INFO',
  Warning: 'WARNING',
  Error: 'ERROR',
  Audit: 'AUDIT',
  All: 'ALL',
} as const;

export type LogEntrySeverity = typeof LogEntrySeverity[keyof typeof LogEntrySeverity];

/**
 *
 * @export
 * @enum {string}
 */

export const PaymentDetailsPaymentType = {
  CreditCard: 'CreditCard',
  Paypal: 'Paypal',
  DirectDebig: 'DirectDebig',
  Invoice: 'Invoice',
} as const;

export type PaymentDetailsPaymentType = typeof PaymentDetailsPaymentType[keyof typeof PaymentDetailsPaymentType];

/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface ProtobufAny
 */
export interface ProtobufAny {
  [key: string]: object | any;

  /**
   * A URL/resource name whose content describes the type of the serialized protocol buffer message.  For URLs which use the scheme `http`, `https`, or no scheme, the following restrictions and interpretations apply:  * If no scheme is provided, `https` is assumed. * The last segment of the URL\'s path must represent the fully   qualified name of the type (as in `path/google.protobuf.Duration`).   The name should be in a canonical form (e.g., leading \".\" is   not accepted). * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
   * @type {string}
   * @memberof ProtobufAny
   */
  '@type'?: string;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the `Value` type union.   The JSON representation for `NullValue` is JSON `null`.   - NULL_VALUE: Null value.
 * @export
 * @enum {string}
 */

export const ProtobufNullValue = {
  NullValue: 'NULL_VALUE',
} as const;

export type ProtobufNullValue = typeof ProtobufNullValue[keyof typeof ProtobufNullValue];

/**
 *
 * @export
 * @interface RpcStatus
 */
export interface RpcStatus {
  /**
   *
   * @type {number}
   * @memberof RpcStatus
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof RpcStatus
   */
  message?: string;
  /**
   *
   * @type {Array<{ [key: string]: object; }>}
   * @memberof RpcStatus
   */
  details?: Array<{ [key: string]: object }>;
}
/**
 *
 * @export
 * @interface V1AccessKey
 */
export interface V1AccessKey {
  /**
   *
   * @type {string}
   * @memberof V1AccessKey
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1AccessKey
   */
  lastUsedAt?: string;
}
/**
 *
 * @export
 * @interface V1Account
 */
export interface V1Account {
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1Account
   */
  status?: V1AccountStatusEnum;
  /**
   *
   * @type {InlineResponse2004AccountPaymentDetails}
   * @memberof V1Account
   */
  paymentDetails?: InlineResponse2004AccountPaymentDetails;
  /**
   *
   * @type {InlineResponse2004AccountContactDetails}
   * @memberof V1Account
   */
  contactDetails?: InlineResponse2004AccountContactDetails;
}

export const V1AccountStatusEnum = {
  Pending: 'PENDING',
  Active: 'ACTIVE',
  Disabled: 'DISABLED',
  Deleted: 'DELETED',
} as const;

export type V1AccountStatusEnum = typeof V1AccountStatusEnum[keyof typeof V1AccountStatusEnum];

/**
 *
 * @export
 * @interface V1AccountRole
 */
export interface V1AccountRole {
  /**
   *
   * @type {string}
   * @memberof V1AccountRole
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1AccountRole
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1AccountRole
   */
  accountRole?: string;
}
/**
 *
 * @export
 * @interface V1Action
 */
export interface V1Action {
  /**
   *
   * @type {string}
   * @memberof V1Action
   */
  service?: string;
  /**
   *
   * @type {string}
   * @memberof V1Action
   */
  call?: string;
}
/**
 *
 * @export
 * @interface V1ActivateAccountRequest
 */
export interface V1ActivateAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1ActivateAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToRoleRequest
 */
export interface V1AddPoliciesToRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddPoliciesToRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToRoleRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToRoleResponse
 */
export interface V1AddPoliciesToRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToRoleResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToUserRequest
 */
export interface V1AddPoliciesToUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddPoliciesToUserRequest
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToUserRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddPoliciesToUserResponse
 */
export interface V1AddPoliciesToUserResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddPoliciesToUserResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddUsersToRoleRequest
 */
export interface V1AddUsersToRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1AddUsersToRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddUsersToRoleResponse
 */
export interface V1AddUsersToRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleResponse
   */
  failedUserIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1AddUsersToRoleResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface V1AddressParams
 */
export interface V1AddressParams {
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  line1?: string;
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  line2?: string;
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  postalCode?: string;
  /**
   *
   * @type {string}
   * @memberof V1AddressParams
   */
  state?: string;
}
/**
 *
 * @export
 * @interface V1AssumeAccountRequest
 */
export interface V1AssumeAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1AssumeAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1BillingData
 */
export interface V1BillingData {
  /**
   *
   * @type {InlineResponse20029BillingDataAddress}
   * @memberof V1BillingData
   */
  address?: InlineResponse20029BillingDataAddress;
  /**
   *
   * @type {InlineResponse20029BillingDataTaxIDData}
   * @memberof V1BillingData
   */
  taxIDData?: InlineResponse20029BillingDataTaxIDData;
}
/**
 *
 * @export
 * @interface V1CancelSubscriptionResponse
 */
export interface V1CancelSubscriptionResponse {
  /**
   *
   * @type {InlineResponse20026Subscription}
   * @memberof V1CancelSubscriptionResponse
   */
  subscription?: InlineResponse20026Subscription;
}
/**
 *
 * @export
 * @interface V1ChangePaymentMethodResponse
 */
export interface V1ChangePaymentMethodResponse {
  /**
   *
   * @type {string}
   * @memberof V1ChangePaymentMethodResponse
   */
  clientSecret?: string;
}
/**
 *
 * @export
 * @interface V1CheckHMACAuthRequest
 */
export interface V1CheckHMACAuthRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  httpMethod?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  requestPath?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  contentType?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  md5Body?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthRequest
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface V1CheckHMACAuthResponse
 */
export interface V1CheckHMACAuthResponse {
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthResponse
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckHMACAuthResponse
   */
  error?: string;
}
/**
 *
 * @export
 * @interface V1CheckRegistrationResponse
 */
export interface V1CheckRegistrationResponse {
  /**
   *
   * @type {number}
   * @memberof V1CheckRegistrationResponse
   */
  statusCode?: number;
  /**
   *
   * @type {string}
   * @memberof V1CheckRegistrationResponse
   */
  errorMessage?: string;
}
/**
 *
 * @export
 * @interface V1CheckTokenAuthRequest
 */
export interface V1CheckTokenAuthRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  authKey?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  signature?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthRequest
   */
  validity?: string;
}
/**
 *
 * @export
 * @interface V1CheckTokenAuthResponse
 */
export interface V1CheckTokenAuthResponse {
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthResponse
   */
  token?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckTokenAuthResponse
   */
  error?: string;
}
/**
 *
 * @export
 * @interface V1CheckUsernameExistsRequest
 */
export interface V1CheckUsernameExistsRequest {
  /**
   *
   * @type {string}
   * @memberof V1CheckUsernameExistsRequest
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1CheckUsernameExistsRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1CheckUsernameExistsResponse
 */
export interface V1CheckUsernameExistsResponse {
  /**
   *
   * @type {boolean}
   * @memberof V1CheckUsernameExistsResponse
   */
  exists?: boolean;
}
/**
 *
 * @export
 * @interface V1ContactDetails
 */
export interface V1ContactDetails {
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  main?: string;
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  finance?: string;
  /**
   *
   * @type {string}
   * @memberof V1ContactDetails
   */
  technical?: string;
}
/**
 *
 * @export
 * @interface V1CreateAccessKeyRequest
 */
export interface V1CreateAccessKeyRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1CreateAccessKeyResponse
 */
export interface V1CreateAccessKeyResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyResponse
   */
  accessKeyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateAccessKeyResponse
   */
  accessSecret?: string;
}
/**
 *
 * @export
 * @interface V1CreateClientRequest
 */
export interface V1CreateClientRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  suffix?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateClientRequest
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface V1CreateClientResponse
 */
export interface V1CreateClientResponse {
  /**
   *
   * @type {InlineResponse2008Client}
   * @memberof V1CreateClientResponse
   */
  client?: InlineResponse2008Client;
}
/**
 *
 * @export
 * @interface V1CreateFederationConfigRequest
 */
export interface V1CreateFederationConfigRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  fedType?: V1CreateFederationConfigRequestFedTypeEnum;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1CreateFederationConfigRequest
   */
  oidcUseSecret?: boolean;
}

export const V1CreateFederationConfigRequestFedTypeEnum = {
  Oidc: 'Oidc',
} as const;

export type V1CreateFederationConfigRequestFedTypeEnum = typeof V1CreateFederationConfigRequestFedTypeEnum[keyof typeof V1CreateFederationConfigRequestFedTypeEnum];

/**
 *
 * @export
 * @interface V1CreateFederationConfigResponse
 */
export interface V1CreateFederationConfigResponse {
  /**
   *
   * @type {InlineResponse20011Config}
   * @memberof V1CreateFederationConfigResponse
   */
  config?: InlineResponse20011Config;
}
/**
 *
 * @export
 * @interface V1CreateNewAccountRequest
 */
export interface V1CreateNewAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountRequest
   */
  description?: string;
  /**
   *
   * @type {InlineResponse2004AccountPaymentDetails}
   * @memberof V1CreateNewAccountRequest
   */
  paymentDetails?: InlineResponse2004AccountPaymentDetails;
  /**
   *
   * @type {InlineResponse2004AccountContactDetails}
   * @memberof V1CreateNewAccountRequest
   */
  contactDetails?: InlineResponse2004AccountContactDetails;
}
/**
 *
 * @export
 * @interface V1CreateNewAccountResponse
 */
export interface V1CreateNewAccountResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateNewAccountResponse
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1CreatePolicyRequest
 */
export interface V1CreatePolicyRequest {
  /**
   *
   * @type {InlineResponse20010Policies}
   * @memberof V1CreatePolicyRequest
   */
  policy?: InlineResponse20010Policies;
}
/**
 *
 * @export
 * @interface V1CreatePolicyResponse
 */
export interface V1CreatePolicyResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreatePolicyResponse
   */
  policyID?: string;
}
/**
 *
 * @export
 * @interface V1CreateRoleRequest
 */
export interface V1CreateRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleRequest
   */
  description?: string;
}
/**
 *
 * @export
 * @interface V1CreateRoleResponse
 */
export interface V1CreateRoleResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateRoleResponse
   */
  roleID?: string;
}
/**
 *
 * @export
 * @interface V1CreateSubscriptionResponse
 */
export interface V1CreateSubscriptionResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateSubscriptionResponse
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateSubscriptionResponse
   */
  clientSecret?: string;
}
/**
 *
 * @export
 * @interface V1CreateUserRequest
 */
export interface V1CreateUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  federationID?: string;
  /**
   *
   * @type {string}
   * @memberof V1CreateUserRequest
   */
  phoneNumber?: string;
}
/**
 *
 * @export
 * @interface V1CreateUserResponse
 */
export interface V1CreateUserResponse {
  /**
   *
   * @type {string}
   * @memberof V1CreateUserResponse
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1CustomerTaxIDDataParams
 */
export interface V1CustomerTaxIDDataParams {
  /**
   *
   * @type {string}
   * @memberof V1CustomerTaxIDDataParams
   */
  type?: string;
  /**
   *
   * @type {string}
   * @memberof V1CustomerTaxIDDataParams
   */
  value?: string;
}
/**
 * A DataPoint represents a single data point in a metrics series and consists  of a timestamp and the value for the metric at the specific time.
 * @export
 * @interface V1DataPoint
 */
export interface V1DataPoint {
  /**
   *
   * @type {string}
   * @memberof V1DataPoint
   */
  t?: string;
  /**
   *
   * @type {number}
   * @memberof V1DataPoint
   */
  v?: number;
}
/**
 *
 * @export
 * @interface V1DeactivateAccountRequest
 */
export interface V1DeactivateAccountRequest {
  /**
   *
   * @type {string}
   * @memberof V1DeactivateAccountRequest
   */
  accountID?: string;
}
/**
 *
 * @export
 * @interface V1FederationConfig
 */
export interface V1FederationConfig {
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  fedID?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  fedType?: V1FederationConfigFedTypeEnum;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcEndpoint?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcClientID?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcClientSecret?: string;
  /**
   *
   * @type {string}
   * @memberof V1FederationConfig
   */
  oidcScopes?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1FederationConfig
   */
  oidcUseSecret?: boolean;
}

export const V1FederationConfigFedTypeEnum = {
  Oidc: 'Oidc',
} as const;

export type V1FederationConfigFedTypeEnum = typeof V1FederationConfigFedTypeEnum[keyof typeof V1FederationConfigFedTypeEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const V1FederationType = {
  Oidc: 'Oidc',
} as const;

export type V1FederationType = typeof V1FederationType[keyof typeof V1FederationType];

/**
 *
 * @export
 * @interface V1GetAccountResponse
 */
export interface V1GetAccountResponse {
  /**
   *
   * @type {InlineResponse2004Account}
   * @memberof V1GetAccountResponse
   */
  account?: InlineResponse2004Account;
}
/**
 *
 * @export
 * @interface V1GetBillingStatusResponse
 */
export interface V1GetBillingStatusResponse {
  /**
   *
   * @type {InlineResponse20029SubscriptionStatus}
   * @memberof V1GetBillingStatusResponse
   */
  subscriptionStatus?: InlineResponse20029SubscriptionStatus;
  /**
   *
   * @type {InlineResponse20029BillingData}
   * @memberof V1GetBillingStatusResponse
   */
  billingData?: InlineResponse20029BillingData;
  /**
   *
   * @type {boolean}
   * @memberof V1GetBillingStatusResponse
   */
  hasSetupPayment?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1GetBillingStatusResponse
   */
  hasSetupSubscription?: boolean;
}
/**
 *
 * @export
 * @interface V1GetClientResponse
 */
export interface V1GetClientResponse {
  /**
   *
   * @type {InlineResponse2008Client}
   * @memberof V1GetClientResponse
   */
  client?: InlineResponse2008Client;
}
/**
 *
 * @export
 * @interface V1GetClientsResponse
 */
export interface V1GetClientsResponse {
  /**
   *
   * @type {Array<InlineResponse2008Client>}
   * @memberof V1GetClientsResponse
   */
  client?: Array<InlineResponse2008Client>;
}
/**
 *
 * @export
 * @interface V1GetDefaultPoliciesResponse
 */
export interface V1GetDefaultPoliciesResponse {
  /**
   *
   * @type {Array<InlineResponse20010Policies>}
   * @memberof V1GetDefaultPoliciesResponse
   */
  policies?: Array<InlineResponse20010Policies>;
}
/**
 *
 * @export
 * @interface V1GetFederationConfigResponse
 */
export interface V1GetFederationConfigResponse {
  /**
   *
   * @type {InlineResponse20011Config}
   * @memberof V1GetFederationConfigResponse
   */
  config?: InlineResponse20011Config;
}
/**
 *
 * @export
 * @interface V1GetLogLabelsResponse
 */
export interface V1GetLogLabelsResponse {
  /**
   *
   * @type {Array<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels>}
   * @memberof V1GetLogLabelsResponse
   */
  loglabels?: Array<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterTheLoglabels>;
}
/**
 * GetMetricsMetaResponse contains a list of metric meta objects, describing all metrics that are currently available in the system.
 * @export
 * @interface V1GetMetricsMetaResponse
 */
export interface V1GetMetricsMetaResponse {
  /**
   *
   * @type {Array<InlineResponse2001Metrics>}
   * @memberof V1GetMetricsMetaResponse
   */
  metrics?: Array<InlineResponse2001Metrics>;
}
/**
 *
 * @export
 * @interface V1GetPasswordPolicyResponse
 */
export interface V1GetPasswordPolicyResponse {
  /**
   *
   * @type {InlineResponse20013Policy}
   * @memberof V1GetPasswordPolicyResponse
   */
  policy?: InlineResponse20013Policy;
}
/**
 *
 * @export
 * @interface V1GetPoliciesResponse
 */
export interface V1GetPoliciesResponse {
  /**
   *
   * @type {Array<InlineResponse20010Policies>}
   * @memberof V1GetPoliciesResponse
   */
  policies?: Array<InlineResponse20010Policies>;
}
/**
 *
 * @export
 * @interface V1GetPolicyResponse
 */
export interface V1GetPolicyResponse {
  /**
   *
   * @type {InlineResponse20010Policies}
   * @memberof V1GetPolicyResponse
   */
  policy?: InlineResponse20010Policies;
}
/**
 *
 * @export
 * @interface V1GetRoleResponse
 */
export interface V1GetRoleResponse {
  /**
   *
   * @type {InlineResponse20019Role}
   * @memberof V1GetRoleResponse
   */
  role?: InlineResponse20019Role;
}
/**
 *
 * @export
 * @interface V1GetRolesResponse
 */
export interface V1GetRolesResponse {
  /**
   *
   * @type {Array<InlineResponse20019Role>}
   * @memberof V1GetRolesResponse
   */
  roles?: Array<InlineResponse20019Role>;
}
/**
 *
 * @export
 * @interface V1GetSubaccountsResponse
 */
export interface V1GetSubaccountsResponse {
  /**
   *
   * @type {Array<InlineResponse2004Account>}
   * @memberof V1GetSubaccountsResponse
   */
  accounts?: Array<InlineResponse2004Account>;
}
/**
 *
 * @export
 * @interface V1GetUserAccessKeysResponse
 */
export interface V1GetUserAccessKeysResponse {
  /**
   *
   * @type {Array<InlineResponse20022Keys>}
   * @memberof V1GetUserAccessKeysResponse
   */
  keys?: Array<InlineResponse20022Keys>;
}
/**
 *
 * @export
 * @interface V1GetUserAccountRolesInternalResponse
 */
export interface V1GetUserAccountRolesInternalResponse {
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof V1GetUserAccountRolesInternalResponse
   */
  roles?: Array<AccountRoles>;
}
/**
 *
 * @export
 * @interface V1GetUserAccountRolesResponse
 */
export interface V1GetUserAccountRolesResponse {
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof V1GetUserAccountRolesResponse
   */
  roles?: Array<AccountRoles>;
}
/**
 *
 * @export
 * @interface V1GetUserIDByEmailResponse
 */
export interface V1GetUserIDByEmailResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetUserIDByEmailResponse
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1GetUserInfoResponse
 */
export interface V1GetUserInfoResponse {
  /**
   *
   * @type {InlineResponse20024UserInfo}
   * @memberof V1GetUserInfoResponse
   */
  userInfo?: InlineResponse20024UserInfo;
}
/**
 *
 * @export
 * @interface V1GetUserResponse
 */
export interface V1GetUserResponse {
  /**
   *
   * @type {InlineResponse20023User}
   * @memberof V1GetUserResponse
   */
  user?: InlineResponse20023User;
}
/**
 *
 * @export
 * @interface V1GetUsersForRoleResponse
 */
export interface V1GetUsersForRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1GetUsersForRoleResponse
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1GetUsersResponse
 */
export interface V1GetUsersResponse {
  /**
   *
   * @type {string}
   * @memberof V1GetUsersResponse
   */
  totalRows?: string;
  /**
   *
   * @type {string}
   * @memberof V1GetUsersResponse
   */
  offset?: string;
  /**
   *
   * @type {number}
   * @memberof V1GetUsersResponse
   */
  limit?: number;
  /**
   *
   * @type {Array<InlineResponse20023User>}
   * @memberof V1GetUsersResponse
   */
  users?: Array<InlineResponse20023User>;
}
/**
 *
 * @export
 * @interface V1InvoiceItem
 */
export interface V1InvoiceItem {
  /**
   *
   * @type {string}
   * @memberof V1InvoiceItem
   */
  amount?: string;
  /**
   *
   * @type {string}
   * @memberof V1InvoiceItem
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof V1InvoiceItem
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1InvoiceItem
   */
  quantity?: string;
}
/**
 * Labels are name-value pairs that are used to annotate metrics or log entries.
 * @export
 * @interface V1Label
 */
export interface V1Label {
  /**
   *
   * @type {string}
   * @memberof V1Label
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Label
   */
  value?: string;
}
/**
 * The LabelFilter is used to filter metrics based on their labels. The filter  can be one of EQ (equals), NE (not-equals), RM (regex-match), and NM (not  matching regex).
 * @export
 * @interface V1LabelFilter
 */
export interface V1LabelFilter {
  /**
   *
   * @type {string}
   * @memberof V1LabelFilter
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1LabelFilter
   */
  value?: string;
  /**
   *
   * @type {string}
   * @memberof V1LabelFilter
   */
  op?: V1LabelFilterOpEnum;
}

export const V1LabelFilterOpEnum = {
  Eq: 'EQ',
  Ne: 'NE',
  Rm: 'RM',
  Nm: 'NM',
} as const;

export type V1LabelFilterOpEnum = typeof V1LabelFilterOpEnum[keyof typeof V1LabelFilterOpEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const V1LabelFilterOperator = {
  Eq: 'EQ',
  Ne: 'NE',
  Rm: 'RM',
  Nm: 'NM',
} as const;

export type V1LabelFilterOperator = typeof V1LabelFilterOperator[keyof typeof V1LabelFilterOperator];

/**
 * LabelValues contain a list of all possible values per label name.
 * @export
 * @interface V1LabelValues
 */
export interface V1LabelValues {
  /**
   *
   * @type {string}
   * @memberof V1LabelValues
   */
  name?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1LabelValues
   */
  values?: Array<string>;
}
/**
 *
 * @export
 * @interface V1ListAccountRolesResponse
 */
export interface V1ListAccountRolesResponse {
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof V1ListAccountRolesResponse
   */
  roles?: Array<AccountRoles>;
}
/**
 * LogEntry is a single log messsage which consists of a set of fields or  attributes, some of which are available to all messages, and others are  specific to the event that created the message.
 * @export
 * @interface V1LogEntry
 */
export interface V1LogEntry {
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  logId?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  time?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  severity?: V1LogEntrySeverityEnum;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  source?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntry
   */
  action?: string;
  /**
   *
   * @type {Array<InlineResponse200Fields>}
   * @memberof V1LogEntry
   */
  fields?: Array<InlineResponse200Fields>;
}

export const V1LogEntrySeverityEnum = {
  Unknown: 'UNKNOWN',
  Trace: 'TRACE',
  Info: 'INFO',
  Warning: 'WARNING',
  Error: 'ERROR',
  Audit: 'AUDIT',
  All: 'ALL',
} as const;

export type V1LogEntrySeverityEnum = typeof V1LogEntrySeverityEnum[keyof typeof V1LogEntrySeverityEnum];

/**
 * A log entry field represents one single attribute of the log entry, which consists of a name and value pair and is not part of the default structure of log messages.
 * @export
 * @interface V1LogEntryField
 */
export interface V1LogEntryField {
  /**
   *
   * @type {string}
   * @memberof V1LogEntryField
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1LogEntryField
   */
  value?: string;
}
/**
 * Aggregations can be used in metric queries to retrieve a summary of the underlying metric data based on single labels.
 * @export
 * @interface V1MetricAggregation
 */
export interface V1MetricAggregation {
  /**
   *
   * @type {string}
   * @memberof V1MetricAggregation
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1MetricAggregation
   */
  op?: V1MetricAggregationOpEnum;
  /**
   *
   * @type {boolean}
   * @memberof V1MetricAggregation
   */
  preserve?: boolean;
}

export const V1MetricAggregationOpEnum = {
  Sum: 'SUM',
  Avg: 'AVG',
  Min: 'MIN',
  Max: 'MAX',
} as const;

export type V1MetricAggregationOpEnum = typeof V1MetricAggregationOpEnum[keyof typeof V1MetricAggregationOpEnum];

/**
 *
 * @export
 * @enum {string}
 */

export const V1MetricAggregationOperator = {
  Sum: 'SUM',
  Avg: 'AVG',
  Min: 'MIN',
  Max: 'MAX',
} as const;

export type V1MetricAggregationOperator = typeof V1MetricAggregationOperator[keyof typeof V1MetricAggregationOperator];

/**
 * MetricMeta contains a name of a metric and a short description, indicating what this metric is representing.
 * @export
 * @interface V1MetricMeta
 */
export interface V1MetricMeta {
  /**
   *
   * @type {string}
   * @memberof V1MetricMeta
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1MetricMeta
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1MetricMeta
   */
  labels?: Array<string>;
}
/**
 * MetricSeries contains the data for a single metric for a requested time span. The object contains both the labels for the result, as well as the actual  data points.
 * @export
 * @interface V1MetricSeries
 */
export interface V1MetricSeries {
  /**
   *
   * @type {string}
   * @memberof V1MetricSeries
   */
  name?: string;
  /**
   *
   * @type {Array<ApiAppscapeV1LogsQueryLabels>}
   * @memberof V1MetricSeries
   */
  labels?: Array<ApiAppscapeV1LogsQueryLabels>;
  /**
   *
   * @type {Array<InlineResponse2002Data>}
   * @memberof V1MetricSeries
   */
  data?: Array<InlineResponse2002Data>;
}
/**
 *
 * @export
 * @interface V1OIDCClient
 */
export interface V1OIDCClient {
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  secret?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  redirectUri?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof V1OIDCClient
   */
  baseColor?: string;
}
/**
 *
 * @export
 * @interface V1PasswordPolicy
 */
export interface V1PasswordPolicy {
  /**
   *
   * @type {string}
   * @memberof V1PasswordPolicy
   */
  minLength?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useLowerLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useUpperLetters?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useNumbers?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof V1PasswordPolicy
   */
  useSpecialCharecters?: boolean;
}
/**
 *
 * @export
 * @interface V1PaymentDetails
 */
export interface V1PaymentDetails {
  /**
   *
   * @type {string}
   * @memberof V1PaymentDetails
   */
  type?: V1PaymentDetailsTypeEnum;
  /**
   *
   * @type {string}
   * @memberof V1PaymentDetails
   */
  info?: string;
}

export const V1PaymentDetailsTypeEnum = {
  CreditCard: 'CreditCard',
  Paypal: 'Paypal',
  DirectDebig: 'DirectDebig',
  Invoice: 'Invoice',
} as const;

export type V1PaymentDetailsTypeEnum = typeof V1PaymentDetailsTypeEnum[keyof typeof V1PaymentDetailsTypeEnum];

/**
 *
 * @export
 * @interface V1Permission
 */
export interface V1Permission {
  /**
   *
   * @type {string}
   * @memberof V1Permission
   */
  effect?: string;
  /**
   *
   * @type {Array<InlineResponse20010Actions>}
   * @memberof V1Permission
   */
  actions?: Array<InlineResponse20010Actions>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1Permission
   */
  scope?: Array<string>;
}
/**
 *
 * @export
 * @interface V1Policy
 */
export interface V1Policy {
  /**
   *
   * @type {string}
   * @memberof V1Policy
   */
  policyID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Policy
   */
  name?: string;
  /**
   *
   * @type {Array<InlineResponse20010Permissions>}
   * @memberof V1Policy
   */
  permissions?: Array<InlineResponse20010Permissions>;
}
/**
 *
 * @export
 * @interface V1Price
 */
export interface V1Price {
  /**
   *
   * @type {string}
   * @memberof V1Price
   */
  id?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1Price
   */
  active?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Price
   */
  billingScheme?: string;
  /**
   *
   * @type {string}
   * @memberof V1Price
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof V1Price
   */
  currency?: string;
}
/**
 *
 * @export
 * @interface V1ProcessRegistrationResponse
 */
export interface V1ProcessRegistrationResponse {
  /**
   *
   * @type {string}
   * @memberof V1ProcessRegistrationResponse
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1ProcessRegistrationResponse
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1ProcessRegistrationResponse
   */
  email?: string;
}
/**
 * The QueryLogsRequest contains all parameters for searching for log entries inside the appscape log store. Those parameters will filter the logs that will be retrieved to only provide entries that macht the values in the  request.
 * @export
 * @interface V1QueryLogsRequest
 */
export interface V1QueryLogsRequest {
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  timeTill?: string;
  /**
   *
   * @type {number}
   * @memberof V1QueryLogsRequest
   */
  limit?: number;
  /**
   *
   * @type {Array<ApiAppscapeV1LogsQueryLabels>}
   * @memberof V1QueryLogsRequest
   */
  labels?: Array<ApiAppscapeV1LogsQueryLabels>;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  match?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryLogsRequest
   */
  notMatch?: string;
}
/**
 * QueryLogsResponse contains a list of log entries that match the request  parameters.
 * @export
 * @interface V1QueryLogsResponse
 */
export interface V1QueryLogsResponse {
  /**
   *
   * @type {Array<InlineResponse200Logs>}
   * @memberof V1QueryLogsResponse
   */
  logs?: Array<InlineResponse200Logs>;
}
/**
 * The QueryMetricsRequest is used to retrieve data for a specific metric in a time period. Additionally, filters can be provided to only retrieve data points for a certain label, as well as aggregations, that can be used to  get a summary over the underlying data.
 * @export
 * @interface V1QueryMetricsRequest
 */
export interface V1QueryMetricsRequest {
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  metric?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  timeFrom?: string;
  /**
   *
   * @type {string}
   * @memberof V1QueryMetricsRequest
   */
  timeTill?: string;
  /**
   *
   * @type {Array<ApiAppscapeV1MetricsQueryFilters>}
   * @memberof V1QueryMetricsRequest
   */
  filters?: Array<ApiAppscapeV1MetricsQueryFilters>;
  /**
   *
   * @type {Array<ApiAppscapeV1MetricsQueryAggregations>}
   * @memberof V1QueryMetricsRequest
   */
  aggregations?: Array<ApiAppscapeV1MetricsQueryAggregations>;
}
/**
 * QueryMetricsResponse contains a list of metrics series objects that hold  data for the respecive metrics, which matches the parameters provided in  the query request.
 * @export
 * @interface V1QueryMetricsResponse
 */
export interface V1QueryMetricsResponse {
  /**
   *
   * @type {Array<InlineResponse2002Metrics>}
   * @memberof V1QueryMetricsResponse
   */
  metrics?: Array<InlineResponse2002Metrics>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromRoleRequest
 */
export interface V1RemovePoliciesFromRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemovePoliciesFromRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromRoleRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromRoleResponse
 */
export interface V1RemovePoliciesFromRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromRoleResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromUserRequest
 */
export interface V1RemovePoliciesFromUserRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemovePoliciesFromUserRequest
   */
  userID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromUserRequest
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemovePoliciesFromUserResponse
 */
export interface V1RemovePoliciesFromUserResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemovePoliciesFromUserResponse
   */
  failedPolicyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemoveUsersFromRoleRequest
 */
export interface V1RemoveUsersFromRoleRequest {
  /**
   *
   * @type {string}
   * @memberof V1RemoveUsersFromRoleRequest
   */
  roleID?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleRequest
   */
  userIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RemoveUsersFromRoleResponse
 */
export interface V1RemoveUsersFromRoleResponse {
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleResponse
   */
  failedUserIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1RemoveUsersFromRoleResponse
   */
  errors?: Array<string>;
}
/**
 *
 * @export
 * @interface V1ResetPasswordRequest
 */
export interface V1ResetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof V1ResetPasswordRequest
   */
  userID?: string;
}
/**
 *
 * @export
 * @interface V1Role
 */
export interface V1Role {
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1Role
   */
  description?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1Role
   */
  policyIDs?: Array<string>;
}
/**
 *
 * @export
 * @interface V1RoleUpdate
 */
export interface V1RoleUpdate {
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  roleID?: string;
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof V1RoleUpdate
   */
  description?: string;
}
/**
 *
 * @export
 * @interface V1SetPasswordRequest
 */
export interface V1SetPasswordRequest {
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  userPassword?: string;
  /**
   *
   * @type {string}
   * @memberof V1SetPasswordRequest
   */
  newPassword?: string;
}
/**
 *
 * @export
 * @interface V1Subscription
 */
export interface V1Subscription {
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  created?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  startDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  currentPeriodStart?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  currentPeriodEnd?: string;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  canceledAt?: string;
  /**
   *
   * @type {boolean}
   * @memberof V1Subscription
   */
  cancelAtPeriodEnd?: boolean;
  /**
   *
   * @type {string}
   * @memberof V1Subscription
   */
  clientSecret?: string;
  /**
   *
   * @type {InlineResponse20026SubscriptionSubscriptionItem}
   * @memberof V1Subscription
   */
  subscriptionItem?: InlineResponse20026SubscriptionSubscriptionItem;
}
/**
 *
 * @export
 * @interface V1SubscriptionItem
 */
export interface V1SubscriptionItem {
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionItem
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionItem
   */
  created?: string;
  /**
   *
   * @type {number}
   * @memberof V1SubscriptionItem
   */
  quantity?: number;
  /**
   *
   * @type {InlineResponse20026SubscriptionSubscriptionItemPrice}
   * @memberof V1SubscriptionItem
   */
  price?: InlineResponse20026SubscriptionSubscriptionItemPrice;
}
/**
 *
 * @export
 * @interface V1SubscriptionStatus
 */
export interface V1SubscriptionStatus {
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  subscriptionID?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  priceID?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  quantity?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  productDescription?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  customerID?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  cardBrand?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  cardLast4?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  nextAmmountDue?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  nextPaymentDate?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  lastAmountPaid?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  lastInvoiceDescription?: string;
  /**
   *
   * @type {string}
   * @memberof V1SubscriptionStatus
   */
  clientSecret?: string;
  /**
   *
   * @type {Array<InlineResponse20029SubscriptionStatusInvoiceItems>}
   * @memberof V1SubscriptionStatus
   */
  invoiceItems?: Array<InlineResponse20029SubscriptionStatusInvoiceItems>;
}
/**
 *
 * @export
 * @interface V1UpdateAccountRequest
 */
export interface V1UpdateAccountRequest {
  /**
   *
   * @type {InlineResponse2004Account}
   * @memberof V1UpdateAccountRequest
   */
  account?: InlineResponse2004Account;
}
/**
 *
 * @export
 * @interface V1UpdateClientResponse
 */
export interface V1UpdateClientResponse {
  /**
   *
   * @type {InlineResponse2008Client}
   * @memberof V1UpdateClientResponse
   */
  client?: InlineResponse2008Client;
}
/**
 *
 * @export
 * @interface V1UpdatePolicyRequest
 */
export interface V1UpdatePolicyRequest {
  /**
   *
   * @type {InlineResponse20010Policies}
   * @memberof V1UpdatePolicyRequest
   */
  policy?: InlineResponse20010Policies;
}
/**
 *
 * @export
 * @interface V1UpdateRoleRequest
 */
export interface V1UpdateRoleRequest {
  /**
   *
   * @type {ApiAuthV1RoleRole}
   * @memberof V1UpdateRoleRequest
   */
  role?: ApiAuthV1RoleRole;
}
/**
 *
 * @export
 * @interface V1UpdateSubscriptionResponse
 */
export interface V1UpdateSubscriptionResponse {
  /**
   *
   * @type {InlineResponse20026Subscription}
   * @memberof V1UpdateSubscriptionResponse
   */
  subscription?: InlineResponse20026Subscription;
}
/**
 *
 * @export
 * @interface V1UpdateUserRequest
 */
export interface V1UpdateUserRequest {
  /**
   *
   * @type {ApiAuthV1UserUserUserIDUser}
   * @memberof V1UpdateUserRequest
   */
  user?: ApiAuthV1UserUserUserIDUser;
}
/**
 *
 * @export
 * @interface V1User
 */
export interface V1User {
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  lastLogin?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof V1User
   */
  policyIDs?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof V1User
   */
  roleIDs?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof V1User
   */
  federationID?: string;
}
/**
 *
 * @export
 * @interface V1UserInfo
 */
export interface V1UserInfo {
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  accountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  name?: string;
  /**
   *
   * @type {Array<InlineResponse20010Policies>}
   * @memberof V1UserInfo
   */
  policies?: Array<InlineResponse20010Policies>;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  logoutUrl?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  assumedAccountID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserInfo
   */
  language?: string;
  /**
   *
   * @type {Array<AccountRoles>}
   * @memberof V1UserInfo
   */
  accountRoles?: Array<AccountRoles>;
}
/**
 *
 * @export
 * @interface V1UserUpdate
 */
export interface V1UserUpdate {
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  userID?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  phoneNumber?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  lastName?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof V1UserUpdate
   */
  federationID?: string;
}

/**
 * AppscapeServiceApi - axios parameter creator
 * @export
 */
export const AppscapeServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogLabels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/appscape/v1/logs/labels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsMeta: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/appscape/v1/metrics/meta`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLogs: async (body: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('queryLogs', 'body', body);
      const localVarPath = `/api/appscape/v1/logs/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryMetrics: async (body: InlineObject1, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('queryMetrics', 'body', body);
      const localVarPath = `/api/appscape/v1/metrics/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AppscapeServiceApi - functional programming interface
 * @export
 */
export const AppscapeServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AppscapeServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLogLabels(
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterThe>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLogLabels(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMetricsMeta(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMetricsMeta(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryLogs(
      body: InlineObject,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryLogs(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryMetrics(
      body: InlineObject1,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryMetrics(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AppscapeServiceApi - factory interface
 * @export
 */
export const AppscapeServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AppscapeServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Retrieve all labels and possible values currently used to index the logs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLogLabels(
      options?: any,
    ): AxiosPromise<GetLogLabelsResponseContainsAListOfAllPossibleLabelNameValuePairsThatCanBeUsedToFilterThe> {
      return localVarFp.getLogLabels(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all available metrics in the system, returning metric name and  short description.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMetricsMeta(options?: any): AxiosPromise<InlineResponse2001> {
      return localVarFp.getMetricsMeta(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve all logs that match the provided filters.
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLogs(body: InlineObject, options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp.queryLogs(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Retrieve data of a metrics, matching the provided parameters.
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryMetrics(body: InlineObject1, options?: any): AxiosPromise<InlineResponse2002> {
      return localVarFp.queryMetrics(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AppscapeServiceApi - object-oriented interface
 * @export
 * @class AppscapeServiceApi
 * @extends {BaseAPI}
 */
export class AppscapeServiceApi extends BaseAPI {
  /**
   *
   * @summary Retrieve all labels and possible values currently used to index the logs.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public getLogLabels(options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .getLogLabels(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all available metrics in the system, returning metric name and  short description.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public getMetricsMeta(options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .getMetricsMeta(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve all logs that match the provided filters.
   * @param {InlineObject} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public queryLogs(body: InlineObject, options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .queryLogs(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Retrieve data of a metrics, matching the provided parameters.
   * @param {InlineObject1} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AppscapeServiceApi
   */
  public queryMetrics(body: InlineObject1, options?: AxiosRequestConfig) {
    return AppscapeServiceApiFp(this.configuration)
      .queryMetrics(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AuthServiceApi - axios parameter creator
 * @export
 */
export const AuthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateAccount: async (body: InlineObject5, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('activateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/activate-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject19} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToRole: async (body: InlineObject19, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addPoliciesToRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/policies/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject25} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToUser: async (body: InlineObject25, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addPoliciesToUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/policies/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject21} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToRole: async (body: InlineObject21, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addUsersToRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/users/add`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `AssignAccountRole`   Scope:   ``
     * @summary AssignAccountRole upserts a record with accountID from context and userID/accountRole from request
     * @param {string} [userID]
     * @param {string} [accountRole]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAccountRole: async (
      userID?: string,
      accountRole?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/assing-account-role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userID !== undefined) {
        localVarQueryParameter['userID'] = userID;
      }

      if (accountRole !== undefined) {
        localVarQueryParameter['accountRole'] = accountRole;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assumeAccount: async (body: InlineObject6, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assumeAccount', 'body', body);
      const localVarPath = `/api/auth/v1/assume-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Auth API
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHMACAuth: async (body: InlineObject7, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkHMACAuth', 'body', body);
      const localVarPath = `/api/auth/v1/check-hmac`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject8} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTokenAuth: async (body: InlineObject8, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkTokenAuth', 'body', body);
      const localVarPath = `/api/auth/v1/check-token`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameExists: async (body: InlineObject9, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('checkUsernameExists', 'body', body);
      const localVarPath = `/api/auth/v1/check-username-exists`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {InlineObject2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccessKey: async (body: InlineObject2, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createAccessKey', 'body', body);
      const localVarPath = `/api/auth/v1/accesskey`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClient: async (body: InlineObject10, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createClient', 'body', body);
      const localVarPath = `/api/auth/v1/client`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFederationConfig: async (body: InlineObject13, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createFederationConfig', 'body', body);
      const localVarPath = `/api/auth/v1/federation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAccount: async (body: InlineObject3, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createNewAccount', 'body', body);
      const localVarPath = `/api/auth/v1/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject15} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicy: async (body: InlineObject15, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPolicy', 'body', body);
      const localVarPath = `/api/auth/v1/policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject18} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole: async (body: InlineObject18, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createRole', 'body', body);
      const localVarPath = `/api/auth/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject24} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (body: InlineObject24, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createUser', 'body', body);
      const localVarPath = `/api/auth/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateAccount: async (body: InlineObject12, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('deactivateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/deactivate-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessKey: async (accessKeyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'accessKeyID' is not null or undefined
      assertParamExists('deleteAccessKey', 'accessKeyID', accessKeyID);
      const localVarPath = `/api/auth/v1/accesskey/{accessKeyID}`.replace(
        `{${'accessKeyID'}}`,
        encodeURIComponent(String(accessKeyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteClient', 'id', id);
      const localVarPath = `/api/auth/v1/client/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicy: async (policyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'policyID' is not null or undefined
      assertParamExists('deletePolicy', 'policyID', policyID);
      const localVarPath = `/api/auth/v1/policy/{policyID}`.replace(
        `{${'policyID'}}`,
        encodeURIComponent(String(policyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole: async (roleID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('deleteRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/{roleID}`.replace(`{${'roleID'}}`, encodeURIComponent(String(roleID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('deleteUser', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClient: async (clientID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'clientID' is not null or undefined
      assertParamExists('getClient', 'clientID', clientID);
      const localVarPath = `/api/auth/v1/client/{clientID}`.replace(
        `{${'clientID'}}`,
        encodeURIComponent(String(clientID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/clients`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPolicies: async (
      offset?: string,
      limit?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/default-policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordPolicy: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/password-policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/policies`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicy: async (policyID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'policyID' is not null or undefined
      assertParamExists('getPolicy', 'policyID', policyID);
      const localVarPath = `/api/auth/v1/policy/{policyID}`.replace(
        `{${'policyID'}}`,
        encodeURIComponent(String(policyID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (roleID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('getRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/{roleID}`.replace(`{${'roleID'}}`, encodeURIComponent(String(roleID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubaccounts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/subaccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUser', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/{userID}`.replace(`{${'userID'}}`, encodeURIComponent(String(userID)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccessKeys: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUserAccessKeys', 'userID', userID);
      const localVarPath = `/api/auth/v1/user/accesskeys/{userID}`.replace(
        `{${'userID'}}`,
        encodeURIComponent(String(userID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccountRoles`   Scope:   ``
     * @summary GetUserAccountRoles fetches all accounts that the current user is member of (has account role)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccountRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/get-user-account-roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIDByEmail: async (email: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'email' is not null or undefined
      assertParamExists('getUserIDByEmail', 'email', email);
      const localVarPath = `/api/auth/v1/user-id-by-email/{email}`.replace(
        `{${'email'}}`,
        encodeURIComponent(String(email)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/userinfo`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (offset?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersForRole: async (
      roleID: string,
      offset?: string,
      limit?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'roleID' is not null or undefined
      assertParamExists('getUsersForRole', 'roleID', roleID);
      const localVarPath = `/api/auth/v1/role/users/{roleID}`.replace(
        `{${'roleID'}}`,
        encodeURIComponent(String(roleID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (offset !== undefined) {
        localVarQueryParameter['offset'] = offset;
      }

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `ListAccountRoles`   Scope:   ``
     * @summary ListAccountRoles fetches all account roles for the current account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccountRoles: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/list-account-roles`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject20} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromRole: async (body: InlineObject20, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removePoliciesFromRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/policies/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject26} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromUser: async (body: InlineObject26, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removePoliciesFromUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/policies/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject22} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUsersFromRole: async (body: InlineObject22, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('removeUsersFromRole', 'body', body);
      const localVarPath = `/api/auth/v1/role/users/remove`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetAssumeAccount: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resetAssumeAccount', 'body', body);
      const localVarPath = `/api/auth/v1/reset-assume-account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject16} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword: async (body: InlineObject16, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('resetPassword', 'body', body);
      const localVarPath = `/api/auth/v1/reset-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Password API
     * @param {InlineObject23} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPassword: async (body: InlineObject23, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setPassword', 'body', body);
      const localVarPath = `/api/auth/v1/set-password`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UnassignAccountRole`   Scope:   ``
     * @summary UnassingAccountRole removes a record with accountID from context and userID from request
     * @param {string} [userID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAccountRole: async (userID?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/auth/v1/unassing-account-role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userID !== undefined) {
        localVarQueryParameter['userID'] = userID;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {InlineObject4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount: async (
      accountAccountID: string,
      body: InlineObject4,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountAccountID' is not null or undefined
      assertParamExists('updateAccount', 'accountAccountID', accountAccountID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateAccount', 'body', body);
      const localVarPath = `/api/auth/v1/account/{account.accountID}`.replace(
        `{${'account.accountID'}}`,
        encodeURIComponent(String(accountAccountID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient: async (id: string, body: InlineObject11, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateClient', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateClient', 'body', body);
      const localVarPath = `/api/auth/v1/client/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject14} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicy: async (body: InlineObject14, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePolicy', 'body', body);
      const localVarPath = `/api/auth/v1/policy`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {InlineObject17} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole: async (body: InlineObject17, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateRole', 'body', body);
      const localVarPath = `/api/auth/v1/role`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} userUserID
     * @param {InlineObject27} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userUserID: string,
      body: InlineObject27,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userUserID' is not null or undefined
      assertParamExists('updateUser', 'userUserID', userUserID);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateUser', 'body', body);
      const localVarPath = `/api/auth/v1/user/{user.userID}`.replace(
        `{${'user.userID'}}`,
        encodeURIComponent(String(userUserID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthServiceApi - functional programming interface
 * @export
 */
export const AuthServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AuthServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activateAccount(
      body: InlineObject5,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activateAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject19} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPoliciesToRole(
      body: InlineObject19,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPoliciesToRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject25} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addPoliciesToUser(
      body: InlineObject25,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addPoliciesToUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject21} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addUsersToRole(
      body: InlineObject21,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addUsersToRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `AssignAccountRole`   Scope:   ``
     * @summary AssignAccountRole upserts a record with accountID from context and userID/accountRole from request
     * @param {string} [userID]
     * @param {string} [accountRole]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignAccountRole(
      userID?: string,
      accountRole?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignAccountRole(userID, accountRole, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assumeAccount(
      body: InlineObject6,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assumeAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Auth API
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkHMACAuth(
      body: InlineObject7,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkHMACAuth(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject8} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkTokenAuth(
      body: InlineObject8,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkTokenAuth(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async checkUsernameExists(
      body: InlineObject9,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.checkUsernameExists(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {InlineObject2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createAccessKey(
      body: InlineObject2,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessKey(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createClient(
      body: InlineObject10,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createClient(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFederationConfig(
      body: InlineObject13,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFederationConfig(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createNewAccount(
      body: InlineObject3,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createNewAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject15} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPolicy(
      body: InlineObject15,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject18} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRole(
      body: InlineObject18,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject24} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body: InlineObject24,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineObject16>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deactivateAccount(
      body: InlineObject12,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAccessKey(
      accessKeyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccessKey(accessKeyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteClient(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePolicy(
      policyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(policyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRole(
      roleID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRole(roleID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClient(
      clientID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClient(clientID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClients(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getClients(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDefaultPolicies(
      offset?: string,
      limit?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDefaultPolicies(offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getOwnAccount(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getOwnAccount(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPasswordPolicy(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPasswordPolicy(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicies(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicies(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPolicy(
      policyID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineObject15>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPolicy(policyID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(
      roleID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRole(roleID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoles(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getRoles(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSubaccounts(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getSubaccounts(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAccessKeys(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccessKeys(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccountRoles`   Scope:   ``
     * @summary GetUserAccountRoles fetches all accounts that the current user is member of (has account role)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserAccountRoles(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAccountRoles(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserIDByEmail(
      email: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineObject16>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserIDByEmail(email, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserInfo(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfo(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      offset?: string,
      limit?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsersForRole(
      roleID: string,
      offset?: string,
      limit?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersForRole(roleID, offset, limit, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `ListAccountRoles`   Scope:   ``
     * @summary ListAccountRoles fetches all account roles for the current account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listAccountRoles(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listAccountRoles(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject20} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePoliciesFromRole(
      body: InlineObject20,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePoliciesFromRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject26} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePoliciesFromUser(
      body: InlineObject26,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePoliciesFromUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject22} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeUsersFromRole(
      body: InlineObject22,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeUsersFromRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetAssumeAccount(
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetAssumeAccount(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject16} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetPassword(
      body: InlineObject16,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetPassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Password API
     * @param {InlineObject23} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPassword(
      body: InlineObject23,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setPassword(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UnassignAccountRole`   Scope:   ``
     * @summary UnassingAccountRole removes a record with accountID from context and userID from request
     * @param {string} [userID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignAccountRole(
      userID?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignAccountRole(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {InlineObject4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateAccount(
      accountAccountID: string,
      body: InlineObject4,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccount(accountAccountID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateClient(
      id: string,
      body: InlineObject11,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateClient(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject14} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePolicy(
      body: InlineObject14,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {InlineObject17} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRole(
      body: InlineObject17,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateRole(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @param {string} userUserID
     * @param {InlineObject27} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userUserID: string,
      body: InlineObject27,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(userUserID, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * AuthServiceApi - factory interface
 * @export
 */
export const AuthServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = AuthServiceApiFp(configuration);
  return {
    /**
     *
     * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activateAccount(body: InlineObject5, options?: any): AxiosPromise<object> {
      return localVarFp.activateAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject19} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToRole(body: InlineObject19, options?: any): AxiosPromise<InlineResponse20016> {
      return localVarFp.addPoliciesToRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject25} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addPoliciesToUser(body: InlineObject25, options?: any): AxiosPromise<InlineResponse20016> {
      return localVarFp.addPoliciesToUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject21} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addUsersToRole(body: InlineObject21, options?: any): AxiosPromise<InlineResponse20017> {
      return localVarFp.addUsersToRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `AssignAccountRole`   Scope:   ``
     * @summary AssignAccountRole upserts a record with accountID from context and userID/accountRole from request
     * @param {string} [userID]
     * @param {string} [accountRole]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAccountRole(userID?: string, accountRole?: string, options?: any): AxiosPromise<object> {
      return localVarFp.assignAccountRole(userID, accountRole, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assumeAccount(body: InlineObject6, options?: any): AxiosPromise<object> {
      return localVarFp.assumeAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Auth API
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkHMACAuth(body: InlineObject7, options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp.checkHMACAuth(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject8} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkTokenAuth(body: InlineObject8, options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp.checkTokenAuth(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
     * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameExists(body: InlineObject9, options?: any): AxiosPromise<InlineResponse2007> {
      return localVarFp.checkUsernameExists(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
     * @summary CreateAccessKey creates a new access key for user
     * @param {InlineObject2} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createAccessKey(body: InlineObject2, options?: any): AxiosPromise<InlineResponse2003> {
      return localVarFp.createAccessKey(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
     * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createClient(body: InlineObject10, options?: any): AxiosPromise<InlineResponse2008> {
      return localVarFp.createClient(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
     * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFederationConfig(body: InlineObject13, options?: any): AxiosPromise<InlineResponse20011> {
      return localVarFp.createFederationConfig(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewAccount(body: InlineObject3, options?: any): AxiosPromise<InlineResponse2005> {
      return localVarFp.createNewAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject15} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPolicy(body: InlineObject15, options?: any): AxiosPromise<InlineResponse20014> {
      return localVarFp.createPolicy(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject18} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRole(body: InlineObject18, options?: any): AxiosPromise<InlineResponse20015> {
      return localVarFp.createRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject24} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: InlineObject24, options?: any): AxiosPromise<InlineObject16> {
      return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deactivateAccount(body: InlineObject12, options?: any): AxiosPromise<object> {
      return localVarFp.deactivateAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
     * @summary DeleteAccessKey deletes access key for user
     * @param {string} accessKeyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAccessKey(accessKeyID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteAccessKey(accessKeyID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
     * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteClient(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteClient(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePolicy(policyID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deletePolicy(policyID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRole(roleID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteRole(roleID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userID: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
     * @summary GetClient loads a specific client.
     * @param {string} clientID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClient(clientID: string, options?: any): AxiosPromise<InlineResponse2008> {
      return localVarFp.getClient(clientID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
     * @summary GetClients loads all clients for account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClients(options?: any): AxiosPromise<InlineResponse2009> {
      return localVarFp.getClients(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDefaultPolicies(offset?: string, limit?: string, options?: any): AxiosPromise<InlineResponse20010> {
      return localVarFp.getDefaultPolicies(offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getOwnAccount(options?: any): AxiosPromise<InlineResponse2004> {
      return localVarFp.getOwnAccount(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPasswordPolicy(options?: any): AxiosPromise<InlineResponse20013> {
      return localVarFp.getPasswordPolicy(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicies(options?: any): AxiosPromise<InlineResponse20010> {
      return localVarFp.getPolicies(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary RBAC API
     * @param {string} policyID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPolicy(policyID: string, options?: any): AxiosPromise<InlineObject15> {
      return localVarFp.getPolicy(policyID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(roleID: string, options?: any): AxiosPromise<InlineResponse20019> {
      return localVarFp.getRole(roleID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles(options?: any): AxiosPromise<InlineResponse20020> {
      return localVarFp.getRoles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSubaccounts(options?: any): AxiosPromise<InlineResponse20021> {
      return localVarFp.getSubaccounts(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userID: string, options?: any): AxiosPromise<InlineResponse20023> {
      return localVarFp.getUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
     * @summary GetUserAccessKeys returns all access keys by user
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccessKeys(userID: string, options?: any): AxiosPromise<InlineResponse20022> {
      return localVarFp.getUserAccessKeys(userID, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccountRoles`   Scope:   ``
     * @summary GetUserAccountRoles fetches all accounts that the current user is member of (has account role)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserAccountRoles(options?: any): AxiosPromise<InlineResponse20012> {
      return localVarFp.getUserAccountRoles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserIDByEmail(email: string, options?: any): AxiosPromise<InlineObject16> {
      return localVarFp.getUserIDByEmail(email, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary User API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserInfo(options?: any): AxiosPromise<InlineResponse20024> {
      return localVarFp.getUserInfo(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} [offset]
     * @param {number} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(offset?: string, limit?: number, options?: any): AxiosPromise<InlineResponse20025> {
      return localVarFp.getUsers(offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} roleID
     * @param {string} [offset]
     * @param {string} [limit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsersForRole(roleID: string, offset?: string, limit?: string, options?: any): AxiosPromise<InlineResponse20018> {
      return localVarFp.getUsersForRole(roleID, offset, limit, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `ListAccountRoles`   Scope:   ``
     * @summary ListAccountRoles fetches all account roles for the current account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listAccountRoles(options?: any): AxiosPromise<InlineResponse20012> {
      return localVarFp.listAccountRoles(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject20} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromRole(body: InlineObject20, options?: any): AxiosPromise<InlineResponse20016> {
      return localVarFp.removePoliciesFromRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject26} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePoliciesFromUser(body: InlineObject26, options?: any): AxiosPromise<InlineResponse20016> {
      return localVarFp.removePoliciesFromUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject22} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeUsersFromRole(body: InlineObject22, options?: any): AxiosPromise<InlineResponse20017> {
      return localVarFp.removeUsersFromRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetAssumeAccount(body: object, options?: any): AxiosPromise<object> {
      return localVarFp.resetAssumeAccount(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject16} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetPassword(body: InlineObject16, options?: any): AxiosPromise<object> {
      return localVarFp.resetPassword(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Password API
     * @param {InlineObject23} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPassword(body: InlineObject23, options?: any): AxiosPromise<object> {
      return localVarFp.setPassword(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UnassignAccountRole`   Scope:   ``
     * @summary UnassingAccountRole removes a record with accountID from context and userID from request
     * @param {string} [userID]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAccountRole(userID?: string, options?: any): AxiosPromise<object> {
      return localVarFp.unassignAccountRole(userID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} accountAccountID
     * @param {InlineObject4} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateAccount(accountAccountID: string, body: InlineObject4, options?: any): AxiosPromise<object> {
      return localVarFp.updateAccount(accountAccountID, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
     * @summary UpdateClient updates the data for account client.
     * @param {string} id
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateClient(id: string, body: InlineObject11, options?: any): AxiosPromise<InlineResponse2008> {
      return localVarFp.updateClient(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject14} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePolicy(body: InlineObject14, options?: any): AxiosPromise<object> {
      return localVarFp.updatePolicy(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {InlineObject17} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRole(body: InlineObject17, options?: any): AxiosPromise<object> {
      return localVarFp.updateRole(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @param {string} userUserID
     * @param {InlineObject27} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(userUserID: string, body: InlineObject27, options?: any): AxiosPromise<object> {
      return localVarFp.updateUser(userUserID, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * AuthServiceApi - object-oriented interface
 * @export
 * @class AuthServiceApi
 * @extends {BaseAPI}
 */
export class AuthServiceApi extends BaseAPI {
  /**
   *
   * @summary ActivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
   * @param {InlineObject5} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public activateAccount(body: InlineObject5, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .activateAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject19} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addPoliciesToRole(body: InlineObject19, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addPoliciesToRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject25} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addPoliciesToUser(body: InlineObject25, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addPoliciesToUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject21} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public addUsersToRole(body: InlineObject21, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .addUsersToRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `AssignAccountRole`   Scope:   ``
   * @summary AssignAccountRole upserts a record with accountID from context and userID/accountRole from request
   * @param {string} [userID]
   * @param {string} [accountRole]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public assignAccountRole(userID?: string, accountRole?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .assignAccountRole(userID, accountRole, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject6} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public assumeAccount(body: InlineObject6, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .assumeAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Auth API
   * @param {InlineObject7} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkHMACAuth(body: InlineObject7, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkHMACAuth(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject8} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkTokenAuth(body: InlineObject8, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkTokenAuth(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CheckUsernameExists`   Scope:   `*`
   * @summary CheckUsernameExists checks in the database if there is already user with the same username If userID is provided and there is already defined username for this userID the method wi return false, so that the username can be used for this user
   * @param {InlineObject9} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public checkUsernameExists(body: InlineObject9, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .checkUsernameExists(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateAccessKey`   Scope:   user ID
   * @summary CreateAccessKey creates a new access key for user
   * @param {InlineObject2} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createAccessKey(body: InlineObject2, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createAccessKey(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateClient`   Scope:
   * @summary CreateClient will try to create a new oidc client for the account with the accountID concatenated with suffix provided in the request. If the client already exists or there are already 20 clients, an error will be returned.
   * @param {InlineObject10} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createClient(body: InlineObject10, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createClient(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `CreateFederationConfig`   Scope:
   * @summary CreateFederationConfig will try to create a new oidc federation configuration,  that can be attached to users. The maximum registered federated configurations per account are 3.
   * @param {InlineObject13} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createFederationConfig(body: InlineObject13, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createFederationConfig(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary CreateNewAccount is dedicated for site admins and automated account creation from other services, that create new user subscriptions
   * @param {InlineObject3} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createNewAccount(body: InlineObject3, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createNewAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject15} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createPolicy(body: InlineObject15, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createPolicy(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject18} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createRole(body: InlineObject18, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject24} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public createUser(body: InlineObject24, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary DeactivateAccount is dedicated for site admins and automated account management from other services, that create can active/deactivate accounts
   * @param {InlineObject12} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deactivateAccount(body: InlineObject12, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deactivateAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `DeleteAccessKey`   Scope:   user ID
   * @summary DeleteAccessKey deletes access key for user
   * @param {string} accessKeyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteAccessKey(accessKeyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteAccessKey(accessKeyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `DeleteClient`   Scope:   client ID
   * @summary DeleteClient will delete the client with the provided ID and return an error, if a key with this ID does not exist, or is not part of accounts clients
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteClient(id: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteClient(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} policyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deletePolicy(policyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deletePolicy(policyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteRole(roleID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteRole(roleID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public deleteUser(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .deleteUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetClient`   Scope:   `clientID`
   * @summary GetClient loads a specific client.
   * @param {string} clientID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getClient(clientID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getClient(clientID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetClients`   Scope:   ``
   * @summary GetClients loads all clients for account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getClients(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getClients(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [offset]
   * @param {string} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getDefaultPolicies(offset?: string, limit?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getDefaultPolicies(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getOwnAccount(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getOwnAccount(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPasswordPolicy(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPasswordPolicy(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPolicies(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPolicies(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary RBAC API
   * @param {string} policyID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getPolicy(policyID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getPolicy(policyID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getRole(roleID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getRole(roleID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getRoles(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getSubaccounts(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getSubaccounts(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUser(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccessKeys`   Scope:   `*`
   * @summary GetUserAccessKeys returns all access keys by user
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserAccessKeys(userID: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserAccessKeys(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `GetUserAccountRoles`   Scope:   ``
   * @summary GetUserAccountRoles fetches all accounts that the current user is member of (has account role)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserAccountRoles(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserAccountRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserIDByEmail(email: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserIDByEmail(email, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary User API
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUserInfo(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUserInfo(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} [offset]
   * @param {number} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUsers(offset?: string, limit?: number, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUsers(offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} roleID
   * @param {string} [offset]
   * @param {string} [limit]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public getUsersForRole(roleID: string, offset?: string, limit?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .getUsersForRole(roleID, offset, limit, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `ListAccountRoles`   Scope:   ``
   * @summary ListAccountRoles fetches all account roles for the current account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public listAccountRoles(options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .listAccountRoles(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject20} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removePoliciesFromRole(body: InlineObject20, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removePoliciesFromRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject26} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removePoliciesFromUser(body: InlineObject26, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removePoliciesFromUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject22} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public removeUsersFromRole(body: InlineObject22, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .removeUsersFromRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public resetAssumeAccount(body: object, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .resetAssumeAccount(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject16} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public resetPassword(body: InlineObject16, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .resetPassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Password API
   * @param {InlineObject23} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public setPassword(body: InlineObject23, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .setPassword(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `UnassignAccountRole`   Scope:   ``
   * @summary UnassingAccountRole removes a record with accountID from context and userID from request
   * @param {string} [userID]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public unassignAccountRole(userID?: string, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .unassignAccountRole(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} accountAccountID
   * @param {InlineObject4} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateAccount(accountAccountID: string, body: InlineObject4, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateAccount(accountAccountID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `auth`   Call:    `UpdateClient`   Scope:   `id`
   * @summary UpdateClient updates the data for account client.
   * @param {string} id
   * @param {InlineObject11} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateClient(id: string, body: InlineObject11, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateClient(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject14} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updatePolicy(body: InlineObject14, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updatePolicy(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {InlineObject17} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateRole(body: InlineObject17, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateRole(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @param {string} userUserID
   * @param {InlineObject27} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthServiceApi
   */
  public updateUser(userUserID: string, body: InlineObject27, options?: AxiosRequestConfig) {
    return AuthServiceApiFp(this.configuration)
      .updateUser(userUserID, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * BillingServiceApi - axios parameter creator
 * @export
 */
export const BillingServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CancelSubscription`   Scope:   ``
     * @summary CancelSubscription cancels a subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/cancel-subscription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangeBillingData`   Scope:   ``
     * @summary ChangeBillingData changes the address and vatID for existing customer.
     * @param {string} [addressParamsCity] City       *string &#x60;form:\&quot;city\&quot;&#x60; Country    *string &#x60;form:\&quot;country\&quot;&#x60; Line1      *string &#x60;form:\&quot;line1\&quot;&#x60; Line2      *string &#x60;form:\&quot;line2\&quot;&#x60; PostalCode *string &#x60;form:\&quot;postal_code\&quot;&#x60; State      *string &#x60;form:\&quot;state\&quot;&#x60;.
     * @param {string} [addressParamsCountry]
     * @param {string} [addressParamsLine1]
     * @param {string} [addressParamsLine2]
     * @param {string} [addressParamsPostalCode]
     * @param {string} [addressParamsState]
     * @param {string} [taxIDDataParamsType] // Type of the tax ID, one of &#x60;ae_trn&#x60;, &#x60;au_abn&#x60;, &#x60;au_arn&#x60;, &#x60;bg_uic&#x60;, &#x60;br_cnpj&#x60;, &#x60;br_cpf&#x60;, &#x60;ca_bn&#x60;, &#x60;ca_gst_hst&#x60;, &#x60;ca_pst_bc&#x60;, &#x60;ca_pst_mb&#x60;, &#x60;ca_pst_sk&#x60;, &#x60;ca_qst&#x60;, &#x60;ch_vat&#x60;, &#x60;cl_tin&#x60;, &#x60;es_cif&#x60;, &#x60;eu_vat&#x60;, &#x60;gb_vat&#x60;, &#x60;ge_vat&#x60;, &#x60;hk_br&#x60;, &#x60;hu_tin&#x60;, &#x60;id_npwp&#x60;, &#x60;il_vat&#x60;, &#x60;in_gst&#x60;, &#x60;is_vat&#x60;, &#x60;jp_cn&#x60;, &#x60;jp_rn&#x60;, &#x60;kr_brn&#x60;, &#x60;li_uid&#x60;, &#x60;mx_rfc&#x60;, &#x60;my_frp&#x60;, &#x60;my_itn&#x60;, &#x60;my_sst&#x60;, &#x60;no_vat&#x60;, &#x60;nz_gst&#x60;, &#x60;ru_inn&#x60;, &#x60;ru_kpp&#x60;, &#x60;sa_vat&#x60;, &#x60;sg_gst&#x60;, &#x60;sg_uen&#x60;, &#x60;si_tin&#x60;, &#x60;th_vat&#x60;, &#x60;tw_vat&#x60;, &#x60;ua_vat&#x60;, &#x60;us_ein&#x60;, or &#x60;za_vat&#x60; Type *string &#x60;form:\&quot;type\&quot;&#x60; // Value of the tax ID. Value *string &#x60;form:\&quot;value\&quot;&#x60;.
     * @param {string} [taxIDDataParamsValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeBillingData: async (
      addressParamsCity?: string,
      addressParamsCountry?: string,
      addressParamsLine1?: string,
      addressParamsLine2?: string,
      addressParamsPostalCode?: string,
      addressParamsState?: string,
      taxIDDataParamsType?: string,
      taxIDDataParamsValue?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/change-billing-data`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (addressParamsCity !== undefined) {
        localVarQueryParameter['addressParams.city'] = addressParamsCity;
      }

      if (addressParamsCountry !== undefined) {
        localVarQueryParameter['addressParams.country'] = addressParamsCountry;
      }

      if (addressParamsLine1 !== undefined) {
        localVarQueryParameter['addressParams.line1'] = addressParamsLine1;
      }

      if (addressParamsLine2 !== undefined) {
        localVarQueryParameter['addressParams.line2'] = addressParamsLine2;
      }

      if (addressParamsPostalCode !== undefined) {
        localVarQueryParameter['addressParams.postalCode'] = addressParamsPostalCode;
      }

      if (addressParamsState !== undefined) {
        localVarQueryParameter['addressParams.state'] = addressParamsState;
      }

      if (taxIDDataParamsType !== undefined) {
        localVarQueryParameter['taxIDDataParams.type'] = taxIDDataParamsType;
      }

      if (taxIDDataParamsValue !== undefined) {
        localVarQueryParameter['taxIDDataParams.value'] = taxIDDataParamsValue;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangePaymentMethod`   Scope:   ``
     * @summary ChangePaymentMethod with a new payment details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethod: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/change-payment-method`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CreateSubscription`   Scope:   ``
     * @summary CreateSubscription creates a new subscription for the logged in account.
     * @param {string} [priceID]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription: async (
      priceID?: string,
      quantity?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/create-subscription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (priceID !== undefined) {
        localVarQueryParameter['priceID'] = priceID;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `GetBillingStatus`   Scope:   ``
     * @summary GetBillingStatus returns the current billing status for logged in account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/get-status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `UpdateSubscription`   Scope:   ``
     * @summary UpdateSubscription with a new payment details.
     * @param {string} [newPriceLookupKey]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription: async (
      newPriceLookupKey?: string,
      quantity?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/api/billing/v1/update-subscription`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (newPriceLookupKey !== undefined) {
        localVarQueryParameter['newPriceLookupKey'] = newPriceLookupKey;
      }

      if (quantity !== undefined) {
        localVarQueryParameter['quantity'] = quantity;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BillingServiceApi - functional programming interface
 * @export
 */
export const BillingServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BillingServiceApiAxiosParamCreator(configuration);
  return {
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CancelSubscription`   Scope:   ``
     * @summary CancelSubscription cancels a subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelSubscription(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelSubscription(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangeBillingData`   Scope:   ``
     * @summary ChangeBillingData changes the address and vatID for existing customer.
     * @param {string} [addressParamsCity] City       *string &#x60;form:\&quot;city\&quot;&#x60; Country    *string &#x60;form:\&quot;country\&quot;&#x60; Line1      *string &#x60;form:\&quot;line1\&quot;&#x60; Line2      *string &#x60;form:\&quot;line2\&quot;&#x60; PostalCode *string &#x60;form:\&quot;postal_code\&quot;&#x60; State      *string &#x60;form:\&quot;state\&quot;&#x60;.
     * @param {string} [addressParamsCountry]
     * @param {string} [addressParamsLine1]
     * @param {string} [addressParamsLine2]
     * @param {string} [addressParamsPostalCode]
     * @param {string} [addressParamsState]
     * @param {string} [taxIDDataParamsType] // Type of the tax ID, one of &#x60;ae_trn&#x60;, &#x60;au_abn&#x60;, &#x60;au_arn&#x60;, &#x60;bg_uic&#x60;, &#x60;br_cnpj&#x60;, &#x60;br_cpf&#x60;, &#x60;ca_bn&#x60;, &#x60;ca_gst_hst&#x60;, &#x60;ca_pst_bc&#x60;, &#x60;ca_pst_mb&#x60;, &#x60;ca_pst_sk&#x60;, &#x60;ca_qst&#x60;, &#x60;ch_vat&#x60;, &#x60;cl_tin&#x60;, &#x60;es_cif&#x60;, &#x60;eu_vat&#x60;, &#x60;gb_vat&#x60;, &#x60;ge_vat&#x60;, &#x60;hk_br&#x60;, &#x60;hu_tin&#x60;, &#x60;id_npwp&#x60;, &#x60;il_vat&#x60;, &#x60;in_gst&#x60;, &#x60;is_vat&#x60;, &#x60;jp_cn&#x60;, &#x60;jp_rn&#x60;, &#x60;kr_brn&#x60;, &#x60;li_uid&#x60;, &#x60;mx_rfc&#x60;, &#x60;my_frp&#x60;, &#x60;my_itn&#x60;, &#x60;my_sst&#x60;, &#x60;no_vat&#x60;, &#x60;nz_gst&#x60;, &#x60;ru_inn&#x60;, &#x60;ru_kpp&#x60;, &#x60;sa_vat&#x60;, &#x60;sg_gst&#x60;, &#x60;sg_uen&#x60;, &#x60;si_tin&#x60;, &#x60;th_vat&#x60;, &#x60;tw_vat&#x60;, &#x60;ua_vat&#x60;, &#x60;us_ein&#x60;, or &#x60;za_vat&#x60; Type *string &#x60;form:\&quot;type\&quot;&#x60; // Value of the tax ID. Value *string &#x60;form:\&quot;value\&quot;&#x60;.
     * @param {string} [taxIDDataParamsValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeBillingData(
      addressParamsCity?: string,
      addressParamsCountry?: string,
      addressParamsLine1?: string,
      addressParamsLine2?: string,
      addressParamsPostalCode?: string,
      addressParamsState?: string,
      taxIDDataParamsType?: string,
      taxIDDataParamsValue?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changeBillingData(
        addressParamsCity,
        addressParamsCountry,
        addressParamsLine1,
        addressParamsLine2,
        addressParamsPostalCode,
        addressParamsState,
        taxIDDataParamsType,
        taxIDDataParamsValue,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangePaymentMethod`   Scope:   ``
     * @summary ChangePaymentMethod with a new payment details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePaymentMethod(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.changePaymentMethod(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CreateSubscription`   Scope:   ``
     * @summary CreateSubscription creates a new subscription for the logged in account.
     * @param {string} [priceID]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createSubscription(
      priceID?: string,
      quantity?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createSubscription(priceID, quantity, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `GetBillingStatus`   Scope:   ``
     * @summary GetBillingStatus returns the current billing status for logged in account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBillingStatus(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBillingStatus(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `UpdateSubscription`   Scope:   ``
     * @summary UpdateSubscription with a new payment details.
     * @param {string} [newPriceLookupKey]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateSubscription(
      newPriceLookupKey?: string,
      quantity?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateSubscription(
        newPriceLookupKey,
        quantity,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BillingServiceApi - factory interface
 * @export
 */
export const BillingServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = BillingServiceApiFp(configuration);
  return {
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CancelSubscription`   Scope:   ``
     * @summary CancelSubscription cancels a subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelSubscription(options?: any): AxiosPromise<InlineResponse20026> {
      return localVarFp.cancelSubscription(options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangeBillingData`   Scope:   ``
     * @summary ChangeBillingData changes the address and vatID for existing customer.
     * @param {string} [addressParamsCity] City       *string &#x60;form:\&quot;city\&quot;&#x60; Country    *string &#x60;form:\&quot;country\&quot;&#x60; Line1      *string &#x60;form:\&quot;line1\&quot;&#x60; Line2      *string &#x60;form:\&quot;line2\&quot;&#x60; PostalCode *string &#x60;form:\&quot;postal_code\&quot;&#x60; State      *string &#x60;form:\&quot;state\&quot;&#x60;.
     * @param {string} [addressParamsCountry]
     * @param {string} [addressParamsLine1]
     * @param {string} [addressParamsLine2]
     * @param {string} [addressParamsPostalCode]
     * @param {string} [addressParamsState]
     * @param {string} [taxIDDataParamsType] // Type of the tax ID, one of &#x60;ae_trn&#x60;, &#x60;au_abn&#x60;, &#x60;au_arn&#x60;, &#x60;bg_uic&#x60;, &#x60;br_cnpj&#x60;, &#x60;br_cpf&#x60;, &#x60;ca_bn&#x60;, &#x60;ca_gst_hst&#x60;, &#x60;ca_pst_bc&#x60;, &#x60;ca_pst_mb&#x60;, &#x60;ca_pst_sk&#x60;, &#x60;ca_qst&#x60;, &#x60;ch_vat&#x60;, &#x60;cl_tin&#x60;, &#x60;es_cif&#x60;, &#x60;eu_vat&#x60;, &#x60;gb_vat&#x60;, &#x60;ge_vat&#x60;, &#x60;hk_br&#x60;, &#x60;hu_tin&#x60;, &#x60;id_npwp&#x60;, &#x60;il_vat&#x60;, &#x60;in_gst&#x60;, &#x60;is_vat&#x60;, &#x60;jp_cn&#x60;, &#x60;jp_rn&#x60;, &#x60;kr_brn&#x60;, &#x60;li_uid&#x60;, &#x60;mx_rfc&#x60;, &#x60;my_frp&#x60;, &#x60;my_itn&#x60;, &#x60;my_sst&#x60;, &#x60;no_vat&#x60;, &#x60;nz_gst&#x60;, &#x60;ru_inn&#x60;, &#x60;ru_kpp&#x60;, &#x60;sa_vat&#x60;, &#x60;sg_gst&#x60;, &#x60;sg_uen&#x60;, &#x60;si_tin&#x60;, &#x60;th_vat&#x60;, &#x60;tw_vat&#x60;, &#x60;ua_vat&#x60;, &#x60;us_ein&#x60;, or &#x60;za_vat&#x60; Type *string &#x60;form:\&quot;type\&quot;&#x60; // Value of the tax ID. Value *string &#x60;form:\&quot;value\&quot;&#x60;.
     * @param {string} [taxIDDataParamsValue]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeBillingData(
      addressParamsCity?: string,
      addressParamsCountry?: string,
      addressParamsLine1?: string,
      addressParamsLine2?: string,
      addressParamsPostalCode?: string,
      addressParamsState?: string,
      taxIDDataParamsType?: string,
      taxIDDataParamsValue?: string,
      options?: any,
    ): AxiosPromise<object> {
      return localVarFp
        .changeBillingData(
          addressParamsCity,
          addressParamsCountry,
          addressParamsLine1,
          addressParamsLine2,
          addressParamsPostalCode,
          addressParamsState,
          taxIDDataParamsType,
          taxIDDataParamsValue,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `ChangePaymentMethod`   Scope:   ``
     * @summary ChangePaymentMethod with a new payment details.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePaymentMethod(options?: any): AxiosPromise<InlineResponse20027> {
      return localVarFp.changePaymentMethod(options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `CreateSubscription`   Scope:   ``
     * @summary CreateSubscription creates a new subscription for the logged in account.
     * @param {string} [priceID]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSubscription(priceID?: string, quantity?: string, options?: any): AxiosPromise<InlineResponse20028> {
      return localVarFp.createSubscription(priceID, quantity, options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `GetBillingStatus`   Scope:   ``
     * @summary GetBillingStatus returns the current billing status for logged in account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillingStatus(options?: any): AxiosPromise<InlineResponse20029> {
      return localVarFp.getBillingStatus(options).then((request) => request(axios, basePath));
    },
    /**
     * Authorisation requirements:   Service:  `billing`   Call:    `UpdateSubscription`   Scope:   ``
     * @summary UpdateSubscription with a new payment details.
     * @param {string} [newPriceLookupKey]
     * @param {string} [quantity]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateSubscription(
      newPriceLookupKey?: string,
      quantity?: string,
      options?: any,
    ): AxiosPromise<InlineResponse20026> {
      return localVarFp
        .updateSubscription(newPriceLookupKey, quantity, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BillingServiceApi - object-oriented interface
 * @export
 * @class BillingServiceApi
 * @extends {BaseAPI}
 */
export class BillingServiceApi extends BaseAPI {
  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `CancelSubscription`   Scope:   ``
   * @summary CancelSubscription cancels a subscription.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public cancelSubscription(options?: AxiosRequestConfig) {
    return BillingServiceApiFp(this.configuration)
      .cancelSubscription(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `ChangeBillingData`   Scope:   ``
   * @summary ChangeBillingData changes the address and vatID for existing customer.
   * @param {string} [addressParamsCity] City       *string &#x60;form:\&quot;city\&quot;&#x60; Country    *string &#x60;form:\&quot;country\&quot;&#x60; Line1      *string &#x60;form:\&quot;line1\&quot;&#x60; Line2      *string &#x60;form:\&quot;line2\&quot;&#x60; PostalCode *string &#x60;form:\&quot;postal_code\&quot;&#x60; State      *string &#x60;form:\&quot;state\&quot;&#x60;.
   * @param {string} [addressParamsCountry]
   * @param {string} [addressParamsLine1]
   * @param {string} [addressParamsLine2]
   * @param {string} [addressParamsPostalCode]
   * @param {string} [addressParamsState]
   * @param {string} [taxIDDataParamsType] // Type of the tax ID, one of &#x60;ae_trn&#x60;, &#x60;au_abn&#x60;, &#x60;au_arn&#x60;, &#x60;bg_uic&#x60;, &#x60;br_cnpj&#x60;, &#x60;br_cpf&#x60;, &#x60;ca_bn&#x60;, &#x60;ca_gst_hst&#x60;, &#x60;ca_pst_bc&#x60;, &#x60;ca_pst_mb&#x60;, &#x60;ca_pst_sk&#x60;, &#x60;ca_qst&#x60;, &#x60;ch_vat&#x60;, &#x60;cl_tin&#x60;, &#x60;es_cif&#x60;, &#x60;eu_vat&#x60;, &#x60;gb_vat&#x60;, &#x60;ge_vat&#x60;, &#x60;hk_br&#x60;, &#x60;hu_tin&#x60;, &#x60;id_npwp&#x60;, &#x60;il_vat&#x60;, &#x60;in_gst&#x60;, &#x60;is_vat&#x60;, &#x60;jp_cn&#x60;, &#x60;jp_rn&#x60;, &#x60;kr_brn&#x60;, &#x60;li_uid&#x60;, &#x60;mx_rfc&#x60;, &#x60;my_frp&#x60;, &#x60;my_itn&#x60;, &#x60;my_sst&#x60;, &#x60;no_vat&#x60;, &#x60;nz_gst&#x60;, &#x60;ru_inn&#x60;, &#x60;ru_kpp&#x60;, &#x60;sa_vat&#x60;, &#x60;sg_gst&#x60;, &#x60;sg_uen&#x60;, &#x60;si_tin&#x60;, &#x60;th_vat&#x60;, &#x60;tw_vat&#x60;, &#x60;ua_vat&#x60;, &#x60;us_ein&#x60;, or &#x60;za_vat&#x60; Type *string &#x60;form:\&quot;type\&quot;&#x60; // Value of the tax ID. Value *string &#x60;form:\&quot;value\&quot;&#x60;.
   * @param {string} [taxIDDataParamsValue]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public changeBillingData(
    addressParamsCity?: string,
    addressParamsCountry?: string,
    addressParamsLine1?: string,
    addressParamsLine2?: string,
    addressParamsPostalCode?: string,
    addressParamsState?: string,
    taxIDDataParamsType?: string,
    taxIDDataParamsValue?: string,
    options?: AxiosRequestConfig,
  ) {
    return BillingServiceApiFp(this.configuration)
      .changeBillingData(
        addressParamsCity,
        addressParamsCountry,
        addressParamsLine1,
        addressParamsLine2,
        addressParamsPostalCode,
        addressParamsState,
        taxIDDataParamsType,
        taxIDDataParamsValue,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `ChangePaymentMethod`   Scope:   ``
   * @summary ChangePaymentMethod with a new payment details.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public changePaymentMethod(options?: AxiosRequestConfig) {
    return BillingServiceApiFp(this.configuration)
      .changePaymentMethod(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `CreateSubscription`   Scope:   ``
   * @summary CreateSubscription creates a new subscription for the logged in account.
   * @param {string} [priceID]
   * @param {string} [quantity]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public createSubscription(priceID?: string, quantity?: string, options?: AxiosRequestConfig) {
    return BillingServiceApiFp(this.configuration)
      .createSubscription(priceID, quantity, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `GetBillingStatus`   Scope:   ``
   * @summary GetBillingStatus returns the current billing status for logged in account.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public getBillingStatus(options?: AxiosRequestConfig) {
    return BillingServiceApiFp(this.configuration)
      .getBillingStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Authorisation requirements:   Service:  `billing`   Call:    `UpdateSubscription`   Scope:   ``
   * @summary UpdateSubscription with a new payment details.
   * @param {string} [newPriceLookupKey]
   * @param {string} [quantity]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillingServiceApi
   */
  public updateSubscription(newPriceLookupKey?: string, quantity?: string, options?: AxiosRequestConfig) {
    return BillingServiceApiFp(this.configuration)
      .updateSubscription(newPriceLookupKey, quantity, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * DistrConfigServiceApi - axios parameter creator
 * @export
 */
export const DistrConfigServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {InlineObject39} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePool: async (body: InlineObject39, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('activatePool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/activate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {InlineObject34} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAppToUsers: async (body: InlineObject34, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignAppToUsers', 'body', body);
      const localVarPath = `/api/distribution/v1/app/users/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {InlineObject32} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPoolsToApp: async (body: InlineObject32, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignPoolsToApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app/pools/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {InlineObject44} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTagToUser: async (body: InlineObject44, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('assignTagToUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user/tags/assign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create mobile application
     * @param {InlineObject31} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApp: async (body: InlineObject31, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {InlineObject38} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPool: async (body: InlineObject38, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {InlineObject42} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPools: async (body: InlineObject42, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createPools', 'body', body);
      const localVarPath = `/api/distribution/v1/pools`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {InlineObject43} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (body: InlineObject43, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApp: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteApp', 'id', id);
      const localVarPath = `/api/distribution/v1/app/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deletePool', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteUser', 'id', id);
      const localVarPath = `/api/distribution/v1/user/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApp: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getApp', 'id', id);
      const localVarPath = `/api/distribution/v1/app/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApps: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/apps`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPool', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolDistribution: async (
      id: string,
      userId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getPoolDistribution', 'id', id);
      const localVarPath = `/api/distribution/v1/pool/distribution/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/pools`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser: async (userID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'userID' is not null or undefined
      assertParamExists('getUser', 'userID', userID);
      const localVarPath = `/api/distribution/v1/user/{userID}`.replace(
        `{${'userID'}}`,
        encodeURIComponent(String(userID)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/distribution/v1/users`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject36} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAppBundle: async (id: string, body: InlineObject36, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('setAppBundle', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('setAppBundle', 'body', body);
      const localVarPath = `/api/distribution/v1/app/{id}/bundle`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {InlineObject35} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAppFromUsers: async (body: InlineObject35, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignAppFromUsers', 'body', body);
      const localVarPath = `/api/distribution/v1/app/users/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {InlineObject33} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignPoolsFromApp: async (body: InlineObject33, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignPoolsFromApp', 'body', body);
      const localVarPath = `/api/distribution/v1/app/pools/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {InlineObject45} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignTagFromUser: async (body: InlineObject45, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('unassignTagFromUser', 'body', body);
      const localVarPath = `/api/distribution/v1/user/tags/unassign`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {InlineObject37} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool: async (body: InlineObject37, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePool', 'body', body);
      const localVarPath = `/api/distribution/v1/pool`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {InlineObject41} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool2: async (
      dataPoolId: string,
      body: InlineObject41,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'dataPoolId' is not null or undefined
      assertParamExists('updatePool2', 'dataPoolId', dataPoolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updatePool2', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/{dataPool.id}`.replace(
        `{${'dataPool.id'}}`,
        encodeURIComponent(String(dataPoolId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {InlineObject40} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePoolData: async (body: InlineObject40, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('validatePoolData', 'body', body);
      const localVarPath = `/api/distribution/v1/pool/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DistrConfigServiceApi - functional programming interface
 * @export
 */
export const DistrConfigServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DistrConfigServiceApiAxiosParamCreator(configuration);
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {InlineObject39} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async activatePool(
      body: InlineObject39,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.activatePool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {InlineObject34} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignAppToUsers(
      body: InlineObject34,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignAppToUsers(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {InlineObject32} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignPoolsToApp(
      body: InlineObject32,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignPoolsToApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {InlineObject44} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async assignTagToUser(
      body: InlineObject44,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.assignTagToUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create mobile application
     * @param {InlineObject31} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createApp(
      body: InlineObject31,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {InlineObject38} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPool(
      body: InlineObject38,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {InlineObject42} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPools(
      body: InlineObject42,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createPools(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {InlineObject43} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body: InlineObject43,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteApp(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApp(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePool(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deletePool(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApp(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApp(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApps(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApps(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPool(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainsDataPoolTaskDataSpecifiedInByIDRequest>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPoolDistribution(
      id: string,
      userId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolDistribution(id, userId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPools(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainsListOfAllDataPoolTasks>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUser(
      userID: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(userID, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject36} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setAppBundle(
      id: string,
      body: InlineObject36,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setAppBundle(id, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {InlineObject35} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignAppFromUsers(
      body: InlineObject35,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignAppFromUsers(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {InlineObject33} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignPoolsFromApp(
      body: InlineObject33,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignPoolsFromApp(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {InlineObject45} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unassignTagFromUser(
      body: InlineObject45,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.unassignTagFromUser(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {InlineObject37} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePool(
      body: InlineObject37,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePool(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {InlineObject41} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePool2(
      dataPoolId: string,
      body: InlineObject41,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePool2(dataPoolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {InlineObject40} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async validatePoolData(
      body: InlineObject40,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.validatePoolData(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * DistrConfigServiceApi - factory interface
 * @export
 */
export const DistrConfigServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DistrConfigServiceApiFp(configuration);
  return {
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
     * @param {InlineObject39} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activatePool(body: InlineObject39, options?: any): AxiosPromise<object> {
      return localVarFp.activatePool(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign mobile application to users
     * @param {InlineObject34} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignAppToUsers(body: InlineObject34, options?: any): AxiosPromise<InlineResponse20035> {
      return localVarFp.assignAppToUsers(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign data pools to mobile application
     * @param {InlineObject32} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignPoolsToApp(body: InlineObject32, options?: any): AxiosPromise<InlineResponse20034> {
      return localVarFp.assignPoolsToApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Assign filtering tag to user
     * @param {InlineObject44} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    assignTagToUser(body: InlineObject44, options?: any): AxiosPromise<object> {
      return localVarFp.assignTagToUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create mobile application
     * @param {InlineObject31} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createApp(body: InlineObject31, options?: any): AxiosPromise<object> {
      return localVarFp.createApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create a data pool that can be used to distribute data to mobile users.
     * @param {InlineObject38} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPool(body: InlineObject38, options?: any): AxiosPromise<object> {
      return localVarFp.createPool(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Create several data pools, which can be used to distribute data to mobile users.
     * @param {InlineObject42} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPools(body: InlineObject42, options?: any): AxiosPromise<object> {
      return localVarFp.createPools(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers user in distribution database
     * @param {InlineObject43} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body: InlineObject43, options?: any): AxiosPromise<object> {
      return localVarFp.createUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteApp(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteApp(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePool(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deletePool(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes user from distribution db
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteUser(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a mobile application
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApp(id: string, options?: any): AxiosPromise<InlineResponse20036> {
      return localVarFp.getApp(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all mobile applications
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApps(options?: any): AxiosPromise<InlineResponse20037> {
      return localVarFp.getApps(options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data pool with the given ID.
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPool(id: string, options?: any): AxiosPromise<ContainsDataPoolTaskDataSpecifiedInByIDRequest> {
      return localVarFp.getPool(id, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the data distribution details for the pool.
     * @param {string} id
     * @param {string} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPoolDistribution(id: string, userId?: string, options?: any): AxiosPromise<InlineResponse20038> {
      return localVarFp.getPoolDistribution(id, userId, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Get the list of all data pool that have been created in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPools(options?: any): AxiosPromise<ContainsListOfAllDataPoolTasks> {
      return localVarFp.getPools(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch the user with the given ID
     * @param {string} userID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUser(userID: string, options?: any): AxiosPromise<InlineResponse20040> {
      return localVarFp.getUser(userID, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch all users in account distribution db
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(options?: any): AxiosPromise<InlineResponse20041> {
      return localVarFp.getUsers(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set the mobile application bundle
     * @param {string} id
     * @param {InlineObject36} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setAppBundle(id: string, body: InlineObject36, options?: any): AxiosPromise<object> {
      return localVarFp.setAppBundle(id, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign mobile application from users
     * @param {InlineObject35} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignAppFromUsers(body: InlineObject35, options?: any): AxiosPromise<InlineResponse20035> {
      return localVarFp.unassignAppFromUsers(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign data pool from mobile application
     * @param {InlineObject33} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignPoolsFromApp(body: InlineObject33, options?: any): AxiosPromise<InlineResponse20034> {
      return localVarFp.unassignPoolsFromApp(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Unassign filtering tag from user
     * @param {InlineObject45} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unassignTagFromUser(body: InlineObject45, options?: any): AxiosPromise<object> {
      return localVarFp.unassignTagFromUser(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {InlineObject37} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool(body: InlineObject37, options?: any): AxiosPromise<object> {
      return localVarFp.updatePool(body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Update an already existing data pool.
     * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
     * @param {InlineObject41} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePool2(dataPoolId: string, body: InlineObject41, options?: any): AxiosPromise<object> {
      return localVarFp.updatePool2(dataPoolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
     * @summary Validate pool data against pool specification
     * @param {InlineObject40} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePoolData(body: InlineObject40, options?: any): AxiosPromise<InlineResponse20039> {
      return localVarFp.validatePoolData(body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * DistrConfigServiceApi - object-oriented interface
 * @export
 * @class DistrConfigServiceApi
 * @extends {BaseAPI}
 */
export class DistrConfigServiceApi extends BaseAPI {
  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request, or           when the pool is already active - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Activate data pool, which will enable the distribution of its data to  mobile users.
   * @param {InlineObject39} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public activatePool(body: InlineObject39, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .activatePool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign mobile application to users
   * @param {InlineObject34} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignAppToUsers(body: InlineObject34, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignAppToUsers(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign data pools to mobile application
   * @param {InlineObject32} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignPoolsToApp(body: InlineObject32, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignPoolsToApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Assign filtering tag to user
   * @param {InlineObject44} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public assignTagToUser(body: InlineObject44, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .assignTagToUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create mobile application
   * @param {InlineObject31} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createApp(body: InlineObject31, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Create a data pool that can be used to distribute data to mobile users.
   * @param {InlineObject38} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createPool(body: InlineObject38, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createPool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definitions are provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Create several data pools, which can be used to distribute data to mobile users.
   * @param {InlineObject42} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createPools(body: InlineObject42, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createPools(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers user in distribution database
   * @param {InlineObject43} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public createUser(body: InlineObject43, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete mobile application
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deleteApp(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deleteApp(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Delete data pool with all its data from the system and the mobile users\'  devices.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deletePool(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deletePool(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes user from distribution db
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public deleteUser(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .deleteUser(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a mobile application
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getApp(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getApp(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all mobile applications
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getApps(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getApps(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the data pool with the given ID.
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPool(id: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPool(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool ID is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the data distribution details for the pool.
   * @param {string} id
   * @param {string} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPoolDistribution(id: string, userId?: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPoolDistribution(id, userId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Get the list of all data pool that have been created in the system.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getPools(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getPools(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch the user with the given ID
   * @param {string} userID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getUser(userID: string, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getUser(userID, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch all users in account distribution db
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public getUsers(options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .getUsers(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set the mobile application bundle
   * @param {string} id
   * @param {InlineObject36} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public setAppBundle(id: string, body: InlineObject36, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .setAppBundle(id, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign mobile application from users
   * @param {InlineObject35} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignAppFromUsers(body: InlineObject35, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignAppFromUsers(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign data pool from mobile application
   * @param {InlineObject33} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignPoolsFromApp(body: InlineObject33, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignPoolsFromApp(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Unassign filtering tag from user
   * @param {InlineObject45} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public unassignTagFromUser(body: InlineObject45, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .unassignTagFromUser(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Update an already existing data pool.
   * @param {InlineObject37} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public updatePool(body: InlineObject37, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .updatePool(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 404    Returned when a pool with the given ID does not exist - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Update an already existing data pool.
   * @param {string} dataPoolId Primary key together with accountId - should be unique by client - used also as name of the pool
   * @param {InlineObject41} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public updatePool2(dataPoolId: string, body: InlineObject41, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .updatePool2(dataPoolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Errors: - 400    Returned when no valid pool definition is provided in the request - 403    Returned when the caller is not allowed to perform this call - 500    Returned whenever an internall error occurs
   * @summary Validate pool data against pool specification
   * @param {InlineObject40} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DistrConfigServiceApi
   */
  public validatePoolData(body: InlineObject40, options?: AxiosRequestConfig) {
    return DistrConfigServiceApiFp(this.configuration)
      .validatePoolData(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FunctionsServiceApi - axios parameter creator
 * @export
 */
export const FunctionsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callAsyncFunction: async (
      reason: string,
      callId: string,
      body: object,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'reason' is not null or undefined
      assertParamExists('callAsyncFunction', 'reason', reason);
      // verify required parameter 'callId' is not null or undefined
      assertParamExists('callAsyncFunction', 'callId', callId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callAsyncFunction', 'body', body);
      const localVarPath = `/api/func/v1/post-call/{reason}/{call.id}`
        .replace(`{${'reason'}}`, encodeURIComponent(String(reason)))
        .replace(`{${'call.id'}}`, encodeURIComponent(String(callId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callSyncFunction: async (
      id: string,
      body: object,
      payloadJSON?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('callSyncFunction', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callSyncFunction', 'body', body);
      const localVarPath = `/api/func/v1/call-sync/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (payloadJSON !== undefined) {
        localVarQueryParameter['payloadJSON'] = payloadJSON;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callTestFunction: async (
      id: string,
      body: object,
      payloadJSON?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('callTestFunction', 'id', id);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('callTestFunction', 'body', body);
      const localVarPath = `/api/func/v1/call-test/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (payloadJSON !== undefined) {
        localVarQueryParameter['payloadJSON'] = payloadJSON;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create function
     * @param {InlineObject29} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFunction: async (body: InlineObject29, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('createFunction', 'body', body);
      const localVarPath = `/api/func/v1/function`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteFunction', 'id', id);
      const localVarPath = `/api/func/v1/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunction: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getFunction', 'id', id);
      const localVarPath = `/api/func/v1/function/{id}`.replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/api/func/v1/functions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update function
     * @param {InlineObject28} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction: async (body: InlineObject28, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateFunction', 'body', body);
      const localVarPath = `/api/func/v1/function`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {InlineObject30} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction2: async (
      functionId: string,
      body: InlineObject30,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'functionId' is not null or undefined
      assertParamExists('updateFunction2', 'functionId', functionId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('updateFunction2', 'body', body);
      const localVarPath = `/api/func/v1/function/{function.id}`.replace(
        `{${'function.id'}}`,
        encodeURIComponent(String(functionId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FunctionsServiceApi - functional programming interface
 * @export
 */
export const FunctionsServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FunctionsServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callAsyncFunction(
      reason: string,
      callId: string,
      body: object,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callAsyncFunction(reason, callId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callSyncFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callSyncFunction(id, body, payloadJSON, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async callTestFunction(
      id: string,
      body: object,
      payloadJSON?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.callTestFunction(id, body, payloadJSON, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create function
     * @param {InlineObject29} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFunction(
      body: InlineObject29,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createFunction(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFunction(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFunction(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunction(
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunction(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFunctions(
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctions(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update function
     * @param {InlineObject28} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFunction(
      body: InlineObject28,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunction(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {InlineObject30} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFunction2(
      functionId: string,
      body: InlineObject30,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunction2(functionId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * FunctionsServiceApi - factory interface
 * @export
 */
export const FunctionsServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FunctionsServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Post function for execution in async way
     * @param {string} reason
     * @param {string} callId
     * @param {object} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callAsyncFunction(reason: string, callId: string, body: object, options?: any): AxiosPromise<object> {
      return localVarFp.callAsyncFunction(reason, callId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Call a function synchroniously
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callSyncFunction(id: string, body: object, payloadJSON?: string, options?: any): AxiosPromise<InlineResponse20030> {
      return localVarFp.callSyncFunction(id, body, payloadJSON, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Test a function call
     * @param {string} id
     * @param {object} body
     * @param {string} [payloadJSON]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    callTestFunction(id: string, body: object, payloadJSON?: string, options?: any): AxiosPromise<InlineResponse20030> {
      return localVarFp.callTestFunction(id, body, payloadJSON, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create function
     * @param {InlineObject29} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFunction(body: InlineObject29, options?: any): AxiosPromise<InlineResponse20031> {
      return localVarFp.createFunction(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFunction(id: string, options?: any): AxiosPromise<object> {
      return localVarFp.deleteFunction(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get function
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunction(id: string, options?: any): AxiosPromise<InlineResponse20032> {
      return localVarFp.getFunction(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Fetch all functions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFunctions(options?: any): AxiosPromise<InlineResponse20033> {
      return localVarFp.getFunctions(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update function
     * @param {InlineObject28} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction(body: InlineObject28, options?: any): AxiosPromise<object> {
      return localVarFp.updateFunction(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update function
     * @param {string} functionId
     * @param {InlineObject30} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFunction2(functionId: string, body: InlineObject30, options?: any): AxiosPromise<object> {
      return localVarFp.updateFunction2(functionId, body, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * FunctionsServiceApi - object-oriented interface
 * @export
 * @class FunctionsServiceApi
 * @extends {BaseAPI}
 */
export class FunctionsServiceApi extends BaseAPI {
  /**
   *
   * @summary Post function for execution in async way
   * @param {string} reason
   * @param {string} callId
   * @param {object} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callAsyncFunction(reason: string, callId: string, body: object, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callAsyncFunction(reason, callId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Call a function synchroniously
   * @param {string} id
   * @param {object} body
   * @param {string} [payloadJSON]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callSyncFunction(id: string, body: object, payloadJSON?: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callSyncFunction(id, body, payloadJSON, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Test a function call
   * @param {string} id
   * @param {object} body
   * @param {string} [payloadJSON]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public callTestFunction(id: string, body: object, payloadJSON?: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .callTestFunction(id, body, payloadJSON, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create function
   * @param {InlineObject29} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public createFunction(body: InlineObject29, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .createFunction(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete function
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public deleteFunction(id: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .deleteFunction(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get function
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public getFunction(id: string, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .getFunction(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Fetch all functions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public getFunctions(options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .getFunctions(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update function
   * @param {InlineObject28} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public updateFunction(body: InlineObject28, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .updateFunction(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update function
   * @param {string} functionId
   * @param {InlineObject30} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FunctionsServiceApi
   */
  public updateFunction2(functionId: string, body: InlineObject30, options?: AxiosRequestConfig) {
    return FunctionsServiceApiFp(this.configuration)
      .updateFunction2(functionId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PoolDataServiceApi - axios parameter creator
 * @export
 */
export const PoolDataServiceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreate: async (
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkCreate', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkCreate', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDelete: async (
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkDelete', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkDelete', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdate: async (
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('bulkUpdate', 'poolId', poolId);
      // verify required parameter 'body' is not null or undefined
      assertParamExists('bulkUpdate', 'body', body);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('deleteAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('deleteAttachment', 'attname', attname);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (poolId: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('get', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('get', 'id', id);
      const localVarPath = `/api/data/_r/{poolId}/{id}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('getAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('getAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('getAttachment', 'attname', attname);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list: async (
      poolId: string,
      limit: number,
      skip: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('list', 'poolId', poolId);
      // verify required parameter 'limit' is not null or undefined
      assertParamExists('list', 'limit', limit);
      // verify required parameter 'skip' is not null or undefined
      assertParamExists('list', 'skip', skip);
      const localVarPath = `/api/data/_r/{poolId}`.replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (limit !== undefined) {
        localVarQueryParameter['limit'] = limit;
      }

      if (skip !== undefined) {
        localVarQueryParameter['skip'] = skip;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeAttachment: async (
      poolId: string,
      id: string,
      attname: string,
      upfile: any,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'poolId' is not null or undefined
      assertParamExists('storeAttachment', 'poolId', poolId);
      // verify required parameter 'id' is not null or undefined
      assertParamExists('storeAttachment', 'id', id);
      // verify required parameter 'attname' is not null or undefined
      assertParamExists('storeAttachment', 'attname', attname);
      // verify required parameter 'upfile' is not null or undefined
      assertParamExists('storeAttachment', 'upfile', upfile);
      const localVarPath = `/api/data/_r/{poolId}/{id}/{attname}`
        .replace(`{${'poolId'}}`, encodeURIComponent(String(poolId)))
        .replace(`{${'id'}}`, encodeURIComponent(String(id)))
        .replace(`{${'attname'}}`, encodeURIComponent(String(attname)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (upfile !== undefined) {
        localVarFormParams.append('upfile', upfile as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PoolDataServiceApi - functional programming interface
 * @export
 */
export const PoolDataServiceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PoolDataServiceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkCreate(
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkCreate(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkDelete(
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDelete(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdate(
      poolId: string,
      body: Array<InlineResponse20042Rows>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdate(poolId, body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAttachment(
      poolId: string,
      id: string,
      attname: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAttachment(poolId, id, attname, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      poolId: string,
      id: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042Rows>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.get(poolId, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAttachment(
      poolId: string,
      id: string,
      attname: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAttachment(poolId, id, attname, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async list(
      poolId: string,
      limit: number,
      skip: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.list(poolId, limit, skip, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async storeAttachment(
      poolId: string,
      id: string,
      attname: string,
      upfile: any,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.storeAttachment(poolId, id, attname, upfile, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * PoolDataServiceApi - factory interface
 * @export
 */
export const PoolDataServiceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = PoolDataServiceApiFp(configuration);
  return {
    /**
     *
     * @summary Bulk create mobile data records in a pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkCreate(poolId: string, body: Array<InlineResponse20042Rows>, options?: any): AxiosPromise<InlineResponse20043> {
      return localVarFp.bulkCreate(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk delete records from mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkDelete(poolId: string, body: Array<InlineResponse20042Rows>, options?: any): AxiosPromise<InlineResponse20044> {
      return localVarFp.bulkDelete(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Bulk update records in mobile data pool
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {Array<InlineResponse20042Rows>} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdate(poolId: string, body: Array<InlineResponse20042Rows>, options?: any): AxiosPromise<InlineResponse20043> {
      return localVarFp.bulkUpdate(poolId, body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAttachment(poolId: string, id: string, attname: string, options?: any): AxiosPromise<string> {
      return localVarFp.deleteAttachment(poolId, id, attname, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get single mobile data record
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(poolId: string, id: string, options?: any): AxiosPromise<InlineResponse20042Rows> {
      return localVarFp.get(poolId, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAttachment(poolId: string, id: string, attname: string, options?: any): AxiosPromise<any> {
      return localVarFp.getAttachment(poolId, id, attname, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List mobile data records
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {number} limit The max number of records to fetch.
     * @param {number} skip The records to skip from the beggining
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    list(poolId: string, limit: number, skip: number, options?: any): AxiosPromise<InlineResponse20042> {
      return localVarFp.list(poolId, limit, skip, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Store attachment
     * @param {string} poolId Pool ID (e.g. orders)
     * @param {string} id The ID (Primary Key) of the record
     * @param {string} attname Attachment name
     * @param {any} upfile The attachment content file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    storeAttachment(poolId: string, id: string, attname: string, upfile: any, options?: any): AxiosPromise<string> {
      return localVarFp
        .storeAttachment(poolId, id, attname, upfile, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PoolDataServiceApi - object-oriented interface
 * @export
 * @class PoolDataServiceApi
 * @extends {BaseAPI}
 */
export class PoolDataServiceApi extends BaseAPI {
  /**
   *
   * @summary Bulk create mobile data records in a pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<InlineResponse20042Rows>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkCreate(poolId: string, body: Array<InlineResponse20042Rows>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkCreate(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Bulk delete records from mobile data pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<InlineResponse20042Rows>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkDelete(poolId: string, body: Array<InlineResponse20042Rows>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkDelete(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Bulk update records in mobile data pool
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {Array<InlineResponse20042Rows>} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public bulkUpdate(poolId: string, body: Array<InlineResponse20042Rows>, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .bulkUpdate(poolId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public deleteAttachment(poolId: string, id: string, attname: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .deleteAttachment(poolId, id, attname, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get single mobile data record
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public get(poolId: string, id: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .get(poolId, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public getAttachment(poolId: string, id: string, attname: string, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .getAttachment(poolId, id, attname, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List mobile data records
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {number} limit The max number of records to fetch.
   * @param {number} skip The records to skip from the beggining
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public list(poolId: string, limit: number, skip: number, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .list(poolId, limit, skip, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Store attachment
   * @param {string} poolId Pool ID (e.g. orders)
   * @param {string} id The ID (Primary Key) of the record
   * @param {string} attname Attachment name
   * @param {any} upfile The attachment content file
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PoolDataServiceApi
   */
  public storeAttachment(poolId: string, id: string, attname: string, upfile: any, options?: AxiosRequestConfig) {
    return PoolDataServiceApiFp(this.configuration)
      .storeAttachment(poolId, id, attname, upfile, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
